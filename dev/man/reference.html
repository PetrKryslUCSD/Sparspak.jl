<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Sparspak.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Sparspak.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../guide/guide.html">Guide</a></li><li class="is-active"><a class="tocitem" href="reference.html">Reference</a><ul class="internal"><li><a class="tocitem" href="#Problem"><span>Problem</span></a></li><li><a class="tocitem" href="#Sparse-LU-Method"><span>Sparse LU Method</span></a></li><li><a class="tocitem" href="#Sparse-LU-SPD-Method"><span>Sparse LU SPD Method</span></a></li><li><a class="tocitem" href="#Elimination-Trees"><span>Elimination Trees</span></a></li><li><a class="tocitem" href="#Graphs"><span>Graphs</span></a></li><li><a class="tocitem" href="#Ordering"><span>Ordering</span></a></li><li><a class="tocitem" href="#Grid"><span>Grid</span></a></li><li class="toplevel"><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Problem-2"><span>Problem</span></a></li><li><a class="tocitem" href="#Sparse-LU-Method-2"><span>Sparse LU Method</span></a></li><li><a class="tocitem" href="#Graphs-2"><span>Graphs</span></a></li><li><a class="tocitem" href="#Ordering-2"><span>Ordering</span></a></li><li><a class="tocitem" href="#Multiple-minimum-degree-(MMD)-ordering."><span>Multiple minimum degree (MMD) ordering.</span></a></li><li><a class="tocitem" href="#Elimination-Trees-2"><span>Elimination Trees</span></a></li><li><a class="tocitem" href="#Symbolic-Factorization"><span>Symbolic Factorization</span></a></li><li><a class="tocitem" href="#Grid-2"><span>Grid</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="reference.html">Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="reference.html">Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/main/docs/src/man/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h1><h2 id="Problem"><a class="docs-heading-anchor" href="#Problem">Problem</a><a id="Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Problem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.Problem" href="#Sparspak.SpkProblem.Problem"><code>Sparspak.SpkProblem.Problem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Problem{IT, FT}</code></pre><p>Type of a sparse-matrix coupled linear algebraic equations problem.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.Problem-Union{Tuple{FT}, Tuple{IT}, Tuple{IT, IT}, Tuple{IT, IT, IT}, Tuple{IT, IT, IT, FT}, Tuple{IT, IT, IT, FT, Any}} where {IT, FT}" href="#Sparspak.SpkProblem.Problem-Union{Tuple{FT}, Tuple{IT}, Tuple{IT, IT}, Tuple{IT, IT, IT}, Tuple{IT, IT, IT, FT}, Tuple{IT, IT, IT, FT, Any}} where {IT, FT}"><code>Sparspak.SpkProblem.Problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Problem(nrows::IT, ncols::IT, nnz::IT=2500, z::FT=0.0, info = &quot;&quot;) where {IT, FT}</code></pre><p>Construct a problem.</p></div></section></article><h2 id="Sparse-LU-Method"><a class="docs-heading-anchor" href="#Sparse-LU-Method">Sparse LU Method</a><a id="Sparse-LU-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-LU-Method" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseSolver.SparseSolver" href="#Sparspak.SpkSparseSolver.SparseSolver"><code>Sparspak.SpkSparseSolver.SparseSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SparseSolver{IT, FT}</code></pre><p>Type of LU general sparse solver.</p></div></section></article><h2 id="Sparse-LU-SPD-Method"><a class="docs-heading-anchor" href="#Sparse-LU-SPD-Method">Sparse LU SPD Method</a><a id="Sparse-LU-SPD-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-LU-SPD-Method" title="Permalink"></a></h2><p>Functions for Symmetric Positive Definite (SPD) matrices.</p><h2 id="Elimination-Trees"><a class="docs-heading-anchor" href="#Elimination-Trees">Elimination Trees</a><a id="Elimination-Trees-1"></a><a class="docs-heading-anchor-permalink" href="#Elimination-Trees" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkETree.ETree-Tuple{IT} where IT" href="#Sparspak.SpkETree.ETree-Tuple{IT} where IT"><code>Sparspak.SpkETree.ETree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ETree(nv::IT) where {IT}</code></pre><p>Construct elimination tree.</p></div></section></article><h2 id="Graphs"><a class="docs-heading-anchor" href="#Graphs">Graphs</a><a id="Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Graphs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkGraph.Graph-Union{Tuple{Sparspak.SpkProblem.Problem{IT}}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT}, Any}} where IT" href="#Sparspak.SpkGraph.Graph-Union{Tuple{Sparspak.SpkProblem.Problem{IT}}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT}, Any}} where IT"><code>Sparspak.SpkGraph.Graph</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This routine constructs a graph from a problem object.</p><p><strong></strong></p><p>It does not check that the problem object contains a structurally   symmetric matrix, since sometimes only the lower or upper triangle of   a symmetric matrix may be stored. There are routines in this module to   make a given graph object structurally symmetric.</p><p><strong></strong></p><p>Input:   g - the graph object, declared by the calling routine   p - the problem object, used to create the graph   diagonal - indicates that the diagonal elements are included. If     diagonal is not given, the adjacency structure does not include     the diagonal elements.   objectName - (optional) name to be assigned to g. Updated Parameter:    g - created graph object.</p></div></section></article><h2 id="Ordering"><a class="docs-heading-anchor" href="#Ordering">Ordering</a><a id="Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#Ordering" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkOrdering.Ordering" href="#Sparspak.SpkOrdering.Ordering"><code>Sparspak.SpkOrdering.Ordering</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Ordering{IT}</code></pre><p>Type of ordering of the rows and columns.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkOrdering.Ordering-Tuple{IT} where IT" href="#Sparspak.SpkOrdering.Ordering-Tuple{IT} where IT"><code>Sparspak.SpkOrdering.Ordering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ordering(nrows::IT) where {IT}</code></pre><p>Construct an ordering object. </p><p>Since only one parameter(<code>nrows</code>) is supplied, it is assumed that the size of the row ordering and column ordering are the same. That is, that the matrix is square.</p><p>Input Parameters:   order - the ordering (declared in the calling program)   nRows - the number of rows (and columns) in the matrix   objectName - the name of the ordering object (optional)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkOrdering.Ordering-Union{Tuple{IT}, Tuple{IT, IT}} where IT" href="#Sparspak.SpkOrdering.Ordering-Union{Tuple{IT}, Tuple{IT, IT}} where IT"><code>Sparspak.SpkOrdering.Ordering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ordering(nrows::IT, ncols::IT) where {IT}</code></pre><p>Construct an ordering object. </p><p>The arrays <code>rperm</code>, <code>cperm</code>, <code>rinvp</code>, <code>cinvp</code> are allocated and initialized to the identity permutation.</p><p>Input Parameter:   order - the ordering (declared in the calling program)   nRows, nCols - the number of rows and columns in the matrix   objectName - the name of the ordering object (optional)</p></div></section></article><h2 id="Grid"><a class="docs-heading-anchor" href="#Grid">Grid</a><a id="Grid-1"></a><a class="docs-heading-anchor-permalink" href="#Grid" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkGrid.Grid-Union{Tuple{IT}, Tuple{IT, IT}} where IT" href="#Sparspak.SpkGrid.Grid-Union{Tuple{IT}, Tuple{IT, IT}} where IT"><code>Sparspak.SpkGrid.Grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Grid(h::IT, k::IT) where {IT}</code></pre><p>Construct a grid with a given number of spacings.</p></div></section></article><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><h2 id="Problem-2"><a class="docs-heading-anchor" href="#Problem-2">Problem</a><a class="docs-heading-anchor-permalink" href="#Problem-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.computeresidual-Union{Tuple{FT}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}, Vector{FT}}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}, Vector{FT}, Any}} where FT" href="#Sparspak.SpkProblem.computeresidual-Union{Tuple{FT}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}, Vector{FT}}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}, Vector{FT}, Any}} where FT"><code>Sparspak.SpkProblem.computeresidual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computeresidual(p::Problem, res::Vector{FT}, xin::Vector{FT} = FT[], mtype = &quot;T&quot;) where {FT}</code></pre><p>Compute the residual of a problem.</p><p>Given a vector <code>x</code>, this routine calculates the difference between the RHS of the given Problem and <code>A*x</code> and places this in <code>res</code>.</p><p>Input:</p><ul><li><code>p</code> - the <code>Problem</code> used to calculate <code>res</code>, using <code>xin</code></li><li><code>xin</code> - the input &quot;solution&quot; vector used to compute the residual</li><li><code>mtype</code> - matrix type (optional). If the matrix is symmetric and only           the lower or upper triangle is present, the user must let           the routine know this by setting mType to one of:               &quot;L&quot; or &quot;l&quot; - when only the lower triangle is present               &quot;U&quot; or &quot;u&quot; - when only the upper triangle is present               &quot;T&quot; or &quot;t&quot; - when either the lower or upper triangle is                            present.</li></ul><p>Output:    res - the calculated residual</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.inaij-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any, Any}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any, Any, Any}} where {IT, FT}" href="#Sparspak.SpkProblem.inaij-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any, Any}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any, Any, Any}} where {IT, FT}"><code>Sparspak.SpkProblem.inaij</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inaij(p::Problem{IT,FT}, rnum, cnum, aij=zero(FT)) where {IT,FT}</code></pre><p>Input a matrix coefficient. </p><p>The value is <em>added</em> to the existing contents.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.inbi-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, IT, FT}} where {IT, FT}" href="#Sparspak.SpkProblem.inbi-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, IT, FT}} where {IT, FT}"><code>Sparspak.SpkProblem.inbi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inbi(p::Problem{IT, FT}, rnum::IT, bi::FT) where {IT, FT}</code></pre><p>Input an entry of the right-hand side vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.infullrhs-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any}} where {IT, FT}" href="#Sparspak.SpkProblem.infullrhs-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any}} where {IT, FT}"><code>Sparspak.SpkProblem.infullrhs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">infullrhs(p::Problem{IT,FT}, rhs)  where {IT,FT}</code></pre><p>InRHSProblem adds a vector of values, rhs, to the current right hand side of a problem object.</p><p>Input:</p><ul><li><code>rhs</code> - the source right-hand side. It <em>must</em> be of length at least       <code>p.nrows</code> and if it is greater than <code>p.nrows</code>, only the first       <code>p.nrows</code> are used.</li></ul><p>Updated:</p><ul><li><code>p</code> - the problem in which rhs is to be inserted.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.insparse-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any}} where {IT, FT}" href="#Sparspak.SpkProblem.insparse-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any}} where {IT, FT}"><code>Sparspak.SpkProblem.insparse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insparse(p::Problem{IT,FT}, spm) where {IT,FT}</code></pre><p>Input sparse matrix.</p><p>Build a problem from a sparse matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.insparse-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Vector{IT}, Vector{IT}, Vector{FT}}} where {IT, FT}" href="#Sparspak.SpkProblem.insparse-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Vector{IT}, Vector{IT}, Vector{FT}}} where {IT, FT}"><code>Sparspak.SpkProblem.insparse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insparse(p::Problem{IT,FT}, I::Vector{IT}, J::Vector{IT}, V::Vector{FT}) where 
{IT,FT}</code></pre><p>Build a problem from a sparse matrix in the COO format.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.makegridproblem-Union{Tuple{IT}, Tuple{IT, IT}} where IT" href="#Sparspak.SpkProblem.makegridproblem-Union{Tuple{IT}, Tuple{IT, IT}} where IT"><code>Sparspak.SpkProblem.makegridproblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makegridproblem(h::IT, k::IT) where {IT}</code></pre><p>Construct a problem object based on a grid.</p><p>Input:</p><ul><li><code>h</code> - the number of rows in the Grid</li><li><code>k</code> - the number of columns in the Grid</li></ul><p>Output:</p><ul><li><code>p</code> - the Problem object to be filled</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.makegridproblem-Union{Tuple{Sparspak.SpkGrid.Grid{IT}}, Tuple{IT}} where IT" href="#Sparspak.SpkProblem.makegridproblem-Union{Tuple{Sparspak.SpkGrid.Grid{IT}}, Tuple{IT}} where IT"><code>Sparspak.SpkProblem.makegridproblem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makegridproblem(g::Grid{IT}) where {IT}</code></pre><p>This routine fills in a problem object using a given grid.</p><p>Input:</p><ul><li><code>g</code> - the <code>Grid</code> to be used to fill a <code>Problem</code> matrix</li></ul><p>Output:</p><ul><li><code>p</code> - the Problem object to be filled</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.makerhs-Union{Tuple{FT}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}, Any}} where FT" href="#Sparspak.SpkProblem.makerhs-Union{Tuple{FT}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}, Any}} where FT"><code>Sparspak.SpkProblem.makerhs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makerhs(p::Problem, x::Vector{FT} = FT[], mtype = &quot;T&quot;) where {FT}</code></pre><p>This routine constructs the RHS of a problem given an <code>x</code> for the equation <code>Ax = rhs</code>. The <code>x</code> must have the same number of elements as the problem (represented by A above) has columns. If <code>x</code> is not present,  a right hand side is contructed so that the solution is 1, 2, 3, ...m.</p><p>Input Parameter:   x - the vector in the equation ``Ax = rhs&quot;&quot;   mType - matrix type (optional). If the matrix is symmetric and only             the lower or upper triangle is present, the user must let             the routine know this by setting mType to one of:                 &quot;L&quot; or &quot;l&quot; - when only the lower triangle is present                 &quot;U&quot; or &quot;u&quot; - when only the upper triangle is present                 &quot;T&quot; or &quot;t&quot; - when either the lower or upper triangle is                              present. Updated Parameter:    p - the problem for which the RHS is being constructed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.outsparse-Union{Tuple{Sparspak.SpkProblem.Problem{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT, FT}" href="#Sparspak.SpkProblem.outsparse-Union{Tuple{Sparspak.SpkProblem.Problem{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT, FT}"><code>Sparspak.SpkProblem.outsparse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outsparse(p::Problem{IT,FT})  where {IT,FT}</code></pre><p>Output the sparse matrix.</p></div></section></article><h2 id="Sparse-LU-Method-2"><a class="docs-heading-anchor" href="#Sparse-LU-Method-2">Sparse LU Method</a><a class="docs-heading-anchor-permalink" href="#Sparse-LU-Method-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseBase.factor-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{IT}} where IT" href="#Sparspak.SpkSparseBase.factor-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{IT}} where IT"><code>Sparspak.SpkSparseBase.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">factor(s::SparseSolver{IT}) where {IT}</code></pre><p>Numerical factorization of the coefficient matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseBase.findorder-Union{Tuple{F}, Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, F}} where {IT, F}" href="#Sparspak.SpkSparseBase.findorder-Union{Tuple{F}, Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, F}} where {IT, F}"><code>Sparspak.SpkSparseBase.findorder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findorder(s::SparseSolver{IT}, orderfunction::F) where {IT, F}</code></pre><p>Find reordering of the coefficient matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseBase.findorder-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{F}, Tuple{IT}} where {IT, F}" href="#Sparspak.SpkSparseBase.findorder-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{F}, Tuple{IT}} where {IT, F}"><code>Sparspak.SpkSparseBase.findorder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findorder(s::SparseSolver{IT}) where {IT, F}</code></pre><p>Find reordering of the coefficient matrix using the default method.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseBase.inmatrix-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT" href="#Sparspak.SpkSparseBase.inmatrix-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT"><code>Sparspak.SpkSparseBase.inmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inmatrix(s::SparseSolver{IT}, p::Problem{IT}) where {IT}</code></pre><p>Put numerical values of the matrix stored in the problem into the data structures of the solver.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseBase.symbolicfactor-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{IT}} where IT" href="#Sparspak.SpkSparseBase.symbolicfactor-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{IT}} where IT"><code>Sparspak.SpkSparseBase.symbolicfactor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symbolicfactor(s::SparseSolver{IT})</code></pre><p>Symbolic factorization of the(reordered) matrix A.</p><p>Create the data structures for the factorization and forward and backward substitution. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseBase.triangularsolve-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT, FT}, Vector{FT}}} where {IT, FT}" href="#Sparspak.SpkSparseBase.triangularsolve-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT, FT}, Vector{FT}}} where {IT, FT}"><code>Sparspak.SpkSparseBase.triangularsolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangularsolve(s::SparseSolver{IT, FT}, solution::Vector{FT}) where {IT, FT}</code></pre><p>Forward and backward substitution (triangular solution).</p><p>Variant where the right-hand side vector is passed in.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseBase.triangularsolve-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT" href="#Sparspak.SpkSparseBase.triangularsolve-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT"><code>Sparspak.SpkSparseBase.triangularsolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangularsolve(s::SparseSolver{IT},  p::Problem{IT}) where {IT}</code></pre><p>Forward and backward substitution (triangular solution).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseSolver.findorderperm-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Any}} where IT" href="#Sparspak.SpkSparseSolver.findorderperm-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Any}} where IT"><code>Sparspak.SpkSparseSolver.findorderperm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findorderperm(s::SparseSolver{IT}, perm) where {IT}</code></pre><p>Find reordering of the coefficient matrix using a given permutation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseSolver.solve-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT" href="#Sparspak.SpkSparseSolver.solve-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT"><code>Sparspak.SpkSparseSolver.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(s::SparseSolver{IT}, p::Problem{IT}) where {IT}</code></pre><p>Execute all the steps of the solution process.</p><p>Given a symmetric matrix <code>A</code>, the steps are:</p><ol><li>Reordering of the matrix <code>A</code>. </li><li>Symbolic factorization of the(reordered) matrix <code>A</code>. </li><li>Putting numerical values of <code>A</code> into the data structures. </li><li>Numerical factorization of <code>A</code>. </li><li>Forward and backward substitution (triangular solution).</li></ol><p>The solution can be retrieved as <code>p.x</code>.</p></div></section></article><h2 id="Graphs-2"><a class="docs-heading-anchor" href="#Graphs-2">Graphs</a><a class="docs-heading-anchor-permalink" href="#Graphs-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkGraph.sortgraph-Union{Tuple{Sparspak.SpkGraph.Graph{IT}}, Tuple{IT}} where IT" href="#Sparspak.SpkGraph.sortgraph-Union{Tuple{Sparspak.SpkGraph.Graph{IT}}, Tuple{IT}} where IT"><code>Sparspak.SpkGraph.sortgraph</code></a> — <span class="docstring-category">Method</span></header><section><div><p>SortGraph - sort the adjacency lists of the graph Important assumption:   This works only for graphs that are symmetric.  Output: updated graph</p></div></section></article><h2 id="Ordering-2"><a class="docs-heading-anchor" href="#Ordering-2">Ordering</a><a class="docs-heading-anchor-permalink" href="#Ordering-2" title="Permalink"></a></h2><h2 id="Multiple-minimum-degree-(MMD)-ordering."><a class="docs-heading-anchor" href="#Multiple-minimum-degree-(MMD)-ordering.">Multiple minimum degree (MMD) ordering.</a><a id="Multiple-minimum-degree-(MMD)-ordering.-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-minimum-degree-(MMD)-ordering." title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkMmd.generalmmd-Union{Tuple{IT}, Tuple{IT, Vector{IT}, Vector{IT}, Vector{IT}, Vector{IT}}} where IT" href="#Sparspak.SpkMmd.generalmmd-Union{Tuple{IT}, Tuple{IT, Vector{IT}, Vector{IT}, Vector{IT}, Vector{IT}}} where IT"><code>Sparspak.SpkMmd.generalmmd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generalmmd(n, xadj, adj, perm, invp)</code></pre><p>This routine implements the minimum degree algorithm.  It makes use of the implicit representation of elimination graphs by quotient graphs, and the notion of indistinguishable nodes.  It also implements the modifications by multiple elimination and minimum external degree.</p><p>Input parameters -</p><ul><li>n - number of equations (xadj, adj) - adjacency structure for the graph. delta - tolerance value for multiple elimination. FIX ME: should delta be passed as argument?</li></ul><p>Output:   perm, invp - the minimum degree Ordering.</p><p>Working arrays -   degHead (deg) - points to first node with degree deg, or 0 if there                are no such nodes.   degNext (node) - points to the next node in the degree list                associated with node, or 0 if node was the last in the                degree list.   degPrev (node) - points to the previous node in a degree list                associated with node, or the negative of the degree of                node (if node was the last in the degree list), or 0                if the node is not in the degree lists.   superSIze - the size of the supernodes.   elimHead - points to the first node eliminated in the current pass                Using elimNext, one can determine all nodes just                eliminated.   elimNext (node) - points to the next node in a eliminated supernode                or 0 if there are no more after node.   marker - marker vector.   mergeParent - the parent map for the merged forest.     needsUpdate (node) - &gt; 0 iff node needs degree update.(0 otherwise)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkMmd.mmdelim-NTuple{13, Any}" href="#Sparspak.SpkMmd.mmdelim-NTuple{13, Any}"><code>Sparspak.SpkMmd.mmdelim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Purpose - This routine eliminates the node mdNode of
  minimum degree from the adjacency structure, which
  is stored in the quotient Graph format.  It also
  transforms the quotient Graph representation of the
  elimination Graph.</code></pre><p>Input parameters -       mdNode - node of minimum degree.       tag - tag value.       invp - the inverse of an incomplete minimum degree Ordering.                 (It is zero at positions where the Ordering is unknown.)    Updated parameters -       (xadj, adjncy) - updated adjacency structure (xadj is not updated).       degHead (deg) - points to first node with degree deg, or 0 if there                    are no such nodes.       degNext (node) - points to the next node in the degree list                    associated with node, or 0 if node was the last in the                    degree list.       degPrev (node) - points to the previous node in a degree list                    associated with node, or the negative of the degree of                    node (if node was the last in the degree list), or 0                    if the node is not in the degree lists.       superSIze - the size of the supernodes.       elimNext (node) - points to the next node in a eliminated supernode                    or 0 if there are no more after node.       marker - marker vector.       mergeParent - the parent map for the merged forest.        needsUpdate (node) - &gt; 0 iff node needs update. (0 otherwise)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkMmd.mmdupdate-NTuple{16, Any}" href="#Sparspak.SpkMmd.mmdupdate-NTuple{16, Any}"><code>Sparspak.SpkMmd.mmdupdate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Purpose - This routine updates the degrees of nodes
  after a multiple elimination step.</code></pre><p>Input parameters -       elimHead - the beginning of the list of eliminated                nodes (i.e., newly formed elements).       neqns - number of equations.       (xadj, adjncy) - adjacency structure.       delta - tolerance value for multiple elimination.       invp - the inverse of an incomplete minimum degree Ordering.                (It is zero at positions where the Ordering is unknown.)    Updated parameters -       mindeg - new minimum degree after degree update.       degHead (deg) - points to first node with degree deg, or 0 if there                    are no such nodes.       degNext (node) - points to the next node in the degree list                    associated with node, or 0 if node was the last in the                    degree list.       degPrev (node) - points to the previous node in a degree list                    associated with node, or the negative of the degree of                    node (if node was the last in the degree list), or 0                    if the node is not in the degree lists.       superSIze - the size of the supernodes.       elimNext (node) - points to the next node in a eliminated supernode                    or 0 if there are no more after node.       marker - marker vector for degree update.       tag - tag value.       mergeParent - the parent map for the merged forest.        needsUpdate (node) - &gt; 0 iff node needs update. (0 otherwise)</p></div></section></article><h2 id="Elimination-Trees-2"><a class="docs-heading-anchor" href="#Elimination-Trees-2">Elimination Trees</a><a class="docs-heading-anchor-permalink" href="#Elimination-Trees-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkETree.binarytree-NTuple{4, Any}" href="#Sparspak.SpkETree.binarytree-NTuple{4, Any}"><code>Sparspak.SpkETree.binarytree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>To determine the binary tree representation of the elimination   tree given by the parent vector.  The returned representation   will be given by the first - son and brother vectors.  The root   of the binary tree is always n.</p><p>Input Parameters:   n - number of equations.   parent - the parent vector of the elimination tree.             It is assumed that parent(i) &gt; i except for the roots.</p><p>Output Parameters:   fson - the first son vector.    brother - the brother vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkETree.findetree-NTuple{6, Any}" href="#Sparspak.SpkETree.findetree-NTuple{6, Any}"><code>Sparspak.SpkETree.findetree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>To determine the elimination tree from a given ordering and the   adjacency structure. The parent vector is returned.</p><p>Input Parameters:   n - number of equations.   (xadj, adj) - the adjacency structure.   (rPerm, rInvp) - permutation and inverse permutation vectors</p><p>Output Parameters:   parent - the parent vector of the elimination tree.</p><p>Working Storage:    ancestor - the ancestor vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkETree.getetree-Tuple{Sparspak.SpkGraph.Graph, Sparspak.SpkOrdering.Ordering, Sparspak.SpkETree.ETree}" href="#Sparspak.SpkETree.getetree-Tuple{Sparspak.SpkGraph.Graph, Sparspak.SpkOrdering.Ordering, Sparspak.SpkETree.ETree}"><code>Sparspak.SpkETree.getetree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a graph and an ordering, GetETree finds the corresponding   elimination tree. It calls the subroutine FindETree, which actually   does the work.</p><p>Input Parameter:   g - the graph whose elimination tree is to be found.   order - the ordering for g</p><p>Updated Parameters:    t - the elimination tree.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkETree.getpostorder-Union{Tuple{IT}, Tuple{Sparspak.SpkETree.ETree{IT}, Sparspak.SpkOrdering.Ordering, Any}} where IT" href="#Sparspak.SpkETree.getpostorder-Union{Tuple{IT}, Tuple{Sparspak.SpkETree.ETree{IT}, Sparspak.SpkOrdering.Ordering, Any}} where IT"><code>Sparspak.SpkETree.getpostorder</code></a> — <span class="docstring-category">Method</span></header><section><div><p>GetPostorder finds a postordering of elimination tree t. The resulting   ordering is returned in the object <span>$order&quot;&quot;. The vector argument$</span>weight&quot;&quot; is optional. If it is present,  the postordering will   be one where the child vertices are ordered in increasing order of   their weights.   The elimination tree is reordered according to the postordering.</p><p>Input Parameters:   t - the e - tree for which the postordering is found.   weight - an optional weighting on the tree</p><p>Updated Parameters:   order - the required ordering</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkETree.postordertree-NTuple{6, Any}" href="#Sparspak.SpkETree.postordertree-NTuple{6, Any}"><code>Sparspak.SpkETree.postordertree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Based on the binary representation (first - son, brother) of the   elimination tree, a postordering is determined. The corresponding   parent vector is also modified to reflect the reordering.</p><p>Input Parameters:   root - root of the elimination tree (usually n).   fson - the first son vector.   brother - the brother vector.</p><p>Updated Parameters:   parent - the parent vector.</p><p>Output Parameters:   rInvpos - inverse permutation for the postordering.</p><p>Working Parameters:    stack - the stack for postorder traversal of the tree.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkETree.weightedbinarytree-NTuple{5, Any}" href="#Sparspak.SpkETree.weightedbinarytree-NTuple{5, Any}"><code>Sparspak.SpkETree.weightedbinarytree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>To determine a binary tree representation of the elimination   tree, for which every &quot;last child&quot; has the maximum possible   column nonzero count in the factor.  The returned representation   will be given by the first - son and brother vectors.  The root of   the binary tree is always n.</p><p>Input Parameters:   n - number of equations.   parent - the parent vector of the elimination tree.             It is assumed that parent(i) &gt; i except for the roots.   weight - a weighting on the tree.</p><p>Output Parameters:   fson - the first son vector.   brother - the brother vector.</p><p>Working Storage:    lson - last son vector.</p></div></section></article><h2 id="Symbolic-Factorization"><a class="docs-heading-anchor" href="#Symbolic-Factorization">Symbolic Factorization</a><a id="Symbolic-Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Factorization" title="Permalink"></a></h2><h2 id="Grid-2"><a class="docs-heading-anchor" href="#Grid-2">Grid</a><a class="docs-heading-anchor-permalink" href="#Grid-2" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../guide/guide.html">« Guide</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Tuesday 7 June 2022 20:04">Tuesday 7 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
