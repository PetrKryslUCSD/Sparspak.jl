<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · Sparspak.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Sparspak.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../guide/guide/">Guide</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Problem"><span>Problem</span></a></li><li><a class="tocitem" href="#Sparse-LU-Method"><span>Sparse LU Method</span></a></li><li><a class="tocitem" href="#Graphs"><span>Graphs</span></a></li><li><a class="tocitem" href="#Ordering"><span>Ordering</span></a></li><li><a class="tocitem" href="#Multiple-minimum-degree-(MMD)-ordering."><span>Multiple minimum degree (MMD) ordering.</span></a></li><li><a class="tocitem" href="#Elimination-Trees"><span>Elimination Trees</span></a></li><li><a class="tocitem" href="#Symbolic-Factorization"><span>Symbolic Factorization</span></a></li><li><a class="tocitem" href="#Grid"><span>Grid</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/main/docs/src/man/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><h2 id="Problem"><a class="docs-heading-anchor" href="#Problem">Problem</a><a id="Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Problem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.infullrhs-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any}} where {IT, FT}" href="#Sparspak.SpkProblem.infullrhs-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any}} where {IT, FT}"><code>Sparspak.SpkProblem.infullrhs</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.makegridproblem-Union{Tuple{IT}, Tuple{IT, IT}} where IT" href="#Sparspak.SpkProblem.makegridproblem-Union{Tuple{IT}, Tuple{IT, IT}} where IT"><code>Sparspak.SpkProblem.makegridproblem</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This routine constructs a Grid object given an H and K, and fills in a   Problem object using this Grid. Input Parameters:   h - the number of rows in the Grid   k - the number of columns in the Grid   stencil - an optional variable specifying the difference operator             to be applied to the grid. Output Parameter:    p - the Problem object to be filled</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.makegridproblem-Union{Tuple{Sparspak.SpkGrid.Grid{IT}}, Tuple{IT}} where IT" href="#Sparspak.SpkProblem.makegridproblem-Union{Tuple{Sparspak.SpkGrid.Grid{IT}}, Tuple{IT}} where IT"><code>Sparspak.SpkProblem.makegridproblem</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This routine fills in a Problem object using a given Grid. Input Parameters:   g - the Grid to be used to fill a Problem matrix   stencil - an optional variable specifying the difference operator             to be applied to the grid. Output Parameter:    p - the Problem object to be filled</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.makerhs-Union{Tuple{Sparspak.SpkProblem.Problem}, Tuple{FT}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}, Any}} where FT" href="#Sparspak.SpkProblem.makerhs-Union{Tuple{Sparspak.SpkProblem.Problem}, Tuple{FT}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}, Any}} where FT"><code>Sparspak.SpkProblem.makerhs</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This routine constructs the RHS of a problem given an x for the   equation <span>$Ax = rhs&quot;&quot;. The x must have the same number of elements   as the problem (represented by A above) has columns.   If x is not present,  a right hand side is contructed so that   (a, the) solution is 1, 2, 3, ...m. Input Parameter:   x - the vector in the equation$</span>Ax = rhs&quot;&quot;   mType - matrix type (optional). If the matrix is symmetric and only             the lower or upper triangle is present, the user must let             the routine know this by setting mType to one of:                 &quot;L&quot; or &quot;l&quot; - when only the lower triangle is present                 &quot;U&quot; or &quot;u&quot; - when only the upper triangle is present                 &quot;T&quot; or &quot;t&quot; - when either the lower or upper triangle is                              present. Updated Parameter:    p - the problem for which the RHS is being constructed.</p></div></section></article><h2 id="Sparse-LU-Method"><a class="docs-heading-anchor" href="#Sparse-LU-Method">Sparse LU Method</a><a id="Sparse-LU-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-LU-Method" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseBase.factor-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{IT}} where IT" href="#Sparspak.SpkSparseBase.factor-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{IT}} where IT"><code>Sparspak.SpkSparseBase.factor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">factor(s::SparseSolver{IT}) where {IT}</code></pre><p>Numerical factorization of the coefficient matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseBase.findorder-Union{Tuple{F}, Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, F}} where {IT, F}" href="#Sparspak.SpkSparseBase.findorder-Union{Tuple{F}, Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, F}} where {IT, F}"><code>Sparspak.SpkSparseBase.findorder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findorder(s::SparseSolver{IT}, orderfunction::F) where {IT, F}</code></pre><p>Find reordering of the coefficient matrix.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseBase.findorder-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{F}, Tuple{IT}} where {IT, F}" href="#Sparspak.SpkSparseBase.findorder-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{F}, Tuple{IT}} where {IT, F}"><code>Sparspak.SpkSparseBase.findorder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findorder(s::SparseSolver{IT}) where {IT, F}</code></pre><p>Find reordering of the coefficient matrix using the default method.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseBase.inmatrix-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT" href="#Sparspak.SpkSparseBase.inmatrix-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT"><code>Sparspak.SpkSparseBase.inmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inmatrix(s::SparseSolver{IT}, p::Problem{IT}) where {IT}</code></pre><p>Put numerical values of the matrix stored in the problem into the data structures of the solver.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseBase.symbolicfactor-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{IT}} where IT" href="#Sparspak.SpkSparseBase.symbolicfactor-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{IT}} where IT"><code>Sparspak.SpkSparseBase.symbolicfactor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">symbolicfactor(s::SparseSolver{IT})</code></pre><p>Symbolic factorization of the(reordered) matrix A and the creation of the data structures for the factorization and forward and backward substitution. </p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseBase.triangularsolve-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT, FT}, Vector{FT}}} where {IT, FT}" href="#Sparspak.SpkSparseBase.triangularsolve-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT, FT}, Vector{FT}}} where {IT, FT}"><code>Sparspak.SpkSparseBase.triangularsolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangularsolve(s::SparseSolver{IT, FT}, solution::Vector{FT}) where {IT, FT}</code></pre><p>Forward and backward substitution (triangular solution).</p><p>Variant where the right-hand side vector is passed in.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseBase.triangularsolve-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT" href="#Sparspak.SpkSparseBase.triangularsolve-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT"><code>Sparspak.SpkSparseBase.triangularsolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangularsolve(s::SparseSolver{IT},  p::Problem{IT}) where {IT}</code></pre><p>Forward and backward substitution (triangular solution).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseSolver.findorderperm-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Any}} where IT" href="#Sparspak.SpkSparseSolver.findorderperm-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Any}} where IT"><code>Sparspak.SpkSparseSolver.findorderperm</code></a> — <span class="docstring-category">Method</span></header><section><div><p>findorderperm(s::SparseSolver{IT}, perm) where {IT}</p><p>Find reordering of the coefficient matrix using a given permutation.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseSolver.solve-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT" href="#Sparspak.SpkSparseSolver.solve-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT"><code>Sparspak.SpkSparseSolver.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(s::SparseSolver{IT}, p::Problem{IT}) where {IT}</code></pre><p>Execute all the steps of the solution process:</p><ol><li><p>Reordering of the matrix A </p></li><li><p>Symbolic factorization of the(reordered) matrix A and the creation of the</p></li></ol><p>data structures for the factorization and forward and backward substitution </p><ol><li>Putting numerical values of</li></ol><p>A into the data structures </p><ol><li><p>Numerical factorization of A </p></li><li><p>Forward and backward substitution (triangular solution) </p></li></ol></div></section></article><h2 id="Graphs"><a class="docs-heading-anchor" href="#Graphs">Graphs</a><a id="Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Graphs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkGraph.sortgraph-Union{Tuple{Sparspak.SpkGraph.Graph{IT}}, Tuple{IT}} where IT" href="#Sparspak.SpkGraph.sortgraph-Union{Tuple{Sparspak.SpkGraph.Graph{IT}}, Tuple{IT}} where IT"><code>Sparspak.SpkGraph.sortgraph</code></a> — <span class="docstring-category">Method</span></header><section><div><p>SortGraph - sort the adjacency lists of the graph Important assumption:   This works only for graphs that are symmetric.  Output: updated graph</p></div></section></article><h2 id="Ordering"><a class="docs-heading-anchor" href="#Ordering">Ordering</a><a id="Ordering-1"></a><a class="docs-heading-anchor-permalink" href="#Ordering" title="Permalink"></a></h2><h2 id="Multiple-minimum-degree-(MMD)-ordering."><a class="docs-heading-anchor" href="#Multiple-minimum-degree-(MMD)-ordering.">Multiple minimum degree (MMD) ordering.</a><a id="Multiple-minimum-degree-(MMD)-ordering.-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-minimum-degree-(MMD)-ordering." title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkMmd.generalmmd-Union{Tuple{IT}, Tuple{IT, Vector{IT}, Vector{IT}, Vector{IT}, Vector{IT}}} where IT" href="#Sparspak.SpkMmd.generalmmd-Union{Tuple{IT}, Tuple{IT, Vector{IT}, Vector{IT}, Vector{IT}, Vector{IT}}} where IT"><code>Sparspak.SpkMmd.generalmmd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generalmmd(n, xadj, adj, perm, invp)</code></pre><p>This routine implements the minimum degree algorithm.  It makes use of the implicit representation of elimination graphs by quotient graphs, and the notion of indistinguishable nodes.  It also implements the modifications by multiple elimination and minimum external degree.</p><p>Input parameters -</p><ul><li>n - number of equations (xadj, adj) - adjacency structure for the graph. delta - tolerance value for multiple elimination. FIX ME: should delta be passed as argument?</li></ul><p>Output:   perm, invp - the minimum degree Ordering.</p><p>Working arrays -   degHead (deg) - points to first node with degree deg, or 0 if there                are no such nodes.   degNext (node) - points to the next node in the degree list                associated with node, or 0 if node was the last in the                degree list.   degPrev (node) - points to the previous node in a degree list                associated with node, or the negative of the degree of                node (if node was the last in the degree list), or 0                if the node is not in the degree lists.   superSIze - the size of the supernodes.   elimHead - points to the first node eliminated in the current pass                Using elimNext, one can determine all nodes just                eliminated.   elimNext (node) - points to the next node in a eliminated supernode                or 0 if there are no more after node.   marker - marker vector.   mergeParent - the parent map for the merged forest.     needsUpdate (node) - &gt; 0 iff node needs degree update.(0 otherwise)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkMmd.mmdelim-NTuple{13, Any}" href="#Sparspak.SpkMmd.mmdelim-NTuple{13, Any}"><code>Sparspak.SpkMmd.mmdelim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Purpose - This routine eliminates the node mdNode of
  minimum degree from the adjacency structure, which
  is stored in the quotient Graph format.  It also
  transforms the quotient Graph representation of the
  elimination Graph.</code></pre><p>Input parameters -       mdNode - node of minimum degree.       tag - tag value.       invp - the inverse of an incomplete minimum degree Ordering.                 (It is zero at positions where the Ordering is unknown.)    Updated parameters -       (xadj, adjncy) - updated adjacency structure (xadj is not updated).       degHead (deg) - points to first node with degree deg, or 0 if there                    are no such nodes.       degNext (node) - points to the next node in the degree list                    associated with node, or 0 if node was the last in the                    degree list.       degPrev (node) - points to the previous node in a degree list                    associated with node, or the negative of the degree of                    node (if node was the last in the degree list), or 0                    if the node is not in the degree lists.       superSIze - the size of the supernodes.       elimNext (node) - points to the next node in a eliminated supernode                    or 0 if there are no more after node.       marker - marker vector.       mergeParent - the parent map for the merged forest.        needsUpdate (node) - &gt; 0 iff node needs update. (0 otherwise)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkMmd.mmdupdate-NTuple{16, Any}" href="#Sparspak.SpkMmd.mmdupdate-NTuple{16, Any}"><code>Sparspak.SpkMmd.mmdupdate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Purpose - This routine updates the degrees of nodes
  after a multiple elimination step.</code></pre><p>Input parameters -       elimHead - the beginning of the list of eliminated                nodes (i.e., newly formed elements).       neqns - number of equations.       (xadj, adjncy) - adjacency structure.       delta - tolerance value for multiple elimination.       invp - the inverse of an incomplete minimum degree Ordering.                (It is zero at positions where the Ordering is unknown.)    Updated parameters -       mindeg - new minimum degree after degree update.       degHead (deg) - points to first node with degree deg, or 0 if there                    are no such nodes.       degNext (node) - points to the next node in the degree list                    associated with node, or 0 if node was the last in the                    degree list.       degPrev (node) - points to the previous node in a degree list                    associated with node, or the negative of the degree of                    node (if node was the last in the degree list), or 0                    if the node is not in the degree lists.       superSIze - the size of the supernodes.       elimNext (node) - points to the next node in a eliminated supernode                    or 0 if there are no more after node.       marker - marker vector for degree update.       tag - tag value.       mergeParent - the parent map for the merged forest.        needsUpdate (node) - &gt; 0 iff node needs update. (0 otherwise)</p></div></section></article><h2 id="Elimination-Trees"><a class="docs-heading-anchor" href="#Elimination-Trees">Elimination Trees</a><a id="Elimination-Trees-1"></a><a class="docs-heading-anchor-permalink" href="#Elimination-Trees" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkETree.binarytree-NTuple{4, Any}" href="#Sparspak.SpkETree.binarytree-NTuple{4, Any}"><code>Sparspak.SpkETree.binarytree</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkETree.findetree-NTuple{6, Any}" href="#Sparspak.SpkETree.findetree-NTuple{6, Any}"><code>Sparspak.SpkETree.findetree</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkETree.getetree-Tuple{Sparspak.SpkGraph.Graph, Sparspak.SpkOrdering.Ordering, Sparspak.SpkETree.ETree}" href="#Sparspak.SpkETree.getetree-Tuple{Sparspak.SpkGraph.Graph, Sparspak.SpkOrdering.Ordering, Sparspak.SpkETree.ETree}"><code>Sparspak.SpkETree.getetree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a graph and an ordering, GetETree finds the corresponding   elimination tree. It calls the subroutine FindETree, which actually   does the work.</p><p>Input Parameter:   g - the graph whose elimination tree is to be found.   order - the ordering for g</p><p>Updated Parameters:    t - the elimination tree.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkETree.getpostorder-Union{Tuple{IT}, Tuple{Sparspak.SpkETree.ETree{IT}, Sparspak.SpkOrdering.Ordering, Any}} where IT" href="#Sparspak.SpkETree.getpostorder-Union{Tuple{IT}, Tuple{Sparspak.SpkETree.ETree{IT}, Sparspak.SpkOrdering.Ordering, Any}} where IT"><code>Sparspak.SpkETree.getpostorder</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkETree.postordertree-NTuple{6, Any}" href="#Sparspak.SpkETree.postordertree-NTuple{6, Any}"><code>Sparspak.SpkETree.postordertree</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkETree.weightedbinarytree-NTuple{5, Any}" href="#Sparspak.SpkETree.weightedbinarytree-NTuple{5, Any}"><code>Sparspak.SpkETree.weightedbinarytree</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><h2 id="Symbolic-Factorization"><a class="docs-heading-anchor" href="#Symbolic-Factorization">Symbolic Factorization</a><a id="Symbolic-Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Factorization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSymfct.findcolumncounts-NTuple{8, Any}" href="#Sparspak.SpkSymfct.findcolumncounts-NTuple{8, Any}"><code>Sparspak.SpkSymfct.findcolumncounts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">This subroutine determines the column counts in
the Cholesky factor.  It uses an algorithm due to Joseph Liu
found in SIMAX 11, 1990, pages 144 - 145.0</code></pre><p>Input parameters:     (i) n - number of equations.     (i) xadj - array of length n + 1, containing pointers                         to the adjacency structure.     (i) adj - array of length xadj(n + 1) - 1, containing                         the adjacency structure.     (i) perm - array of length n, containing the                         postordering.     (i) invp - array of length n, containing the                         inverse of the postordering.     (i) parent - array of length n, containing the                         elimination tree of the postordered matrix.</p><p>Output parameters:     (i) colcnt - array of length n, containing the number                         of nonzeros in each column of the factor,                         including the diagonal entry.     (i) nlnz - number of nonzeros in the factor, including                         the diagonal entries.</p><p>Work parameters:     (i) marker - array of length n used to mark the                          vertices visited in each row subtree.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSymfct.findnumberofsupermods-NTuple{7, Any}" href="#Sparspak.SpkSymfct.findnumberofsupermods-NTuple{7, Any}"><code>Sparspak.SpkSymfct.findnumberofsupermods</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSymfct.findschedule-NTuple{6, Any}" href="#Sparspak.SpkSymfct.findschedule-NTuple{6, Any}"><code>Sparspak.SpkSymfct.findschedule</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSymfct.findsupernodes-NTuple{8, Any}" href="#Sparspak.SpkSymfct.findsupernodes-NTuple{8, Any}"><code>Sparspak.SpkSymfct.findsupernodes</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSymfct.findsupernodetree-NTuple{6, Any}" href="#Sparspak.SpkSymfct.findsupernodetree-NTuple{6, Any}"><code>Sparspak.SpkSymfct.findsupernodetree</code></a> — <span class="docstring-category">Method</span></header><section><div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSymfct.symbolicfact-NTuple{12, Any}" href="#Sparspak.SpkSymfct.symbolicfact-NTuple{12, Any}"><code>Sparspak.SpkSymfct.symbolicfact</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">This routine performs supernodal symbolic
factorization on a reordered linear system.
This is essentially a Fortran 90 translation of a code written
by Esmond Ng and Barry Peyton.</code></pre><p>Input parameters:     (i) n - number of equations     (i) xadj - array of length n + 1 containing pointers                         to the adjacency structure.     (i) adj - array of length xadj(n + 1) - 1 containing                         the adjacency structure.     (i) perm - array of length n containing the                         postordering.     (i) invp - array of length n containing the                         inverse of the postordering.     (i) colcnt - array of length n, containing the number                         of nonzeros (non - empty rows) in each                         column of the factor,                         including the diagonal entry.     (i) nsuper - number of supernodes.     (i) xsuper - array of length nsuper + 1, containing the                         first column of each supernode.     (i) snode - array of length n for recording                         supernode membership.     (i) nofsub - number of subscripts to be stored in                         lindx.</p><p>Output parameters:     (i) xlindx - array of length n + 1, containing pointers                         into the subscript vector.     (i) lindx - array of length maxsub, containing the                         compressed subscripts.     (i) xlnz - column pointers for l.</p><p>Working parameters:     (i) mrglnk - array of length nsuper, containing the                         children of each supernode as a linked list.     (i) rchlnk - array of length n + 1, containing the                         current linked list of merged indices (the                         &quot;reach&quot; set).     (i) marker - array of length n used to mark indices                         as they are introduced into each supernode&quot;s                         index set.</p></div></section></article><h2 id="Grid"><a class="docs-heading-anchor" href="#Grid">Grid</a><a id="Grid-1"></a><a class="docs-heading-anchor-permalink" href="#Grid" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Types</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Tuesday 7 June 2022 17:18">Tuesday 7 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
