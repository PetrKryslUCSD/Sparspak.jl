<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · Sparspak.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Sparspak.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../howto/howto/">How to</a></li><li><a class="tocitem" href="../../tutorials/tutorials/">Tutorials</a></li><li><a class="tocitem" href="../../concepts/concepts/">Concepts</a></li><li><a class="tocitem" href="../man/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/main/docs/src/man/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><h2 id="Problem"><a class="docs-heading-anchor" href="#Problem">Problem</a><a id="Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Problem" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.Problem-Union{Tuple{FT}, Tuple{IT}, Tuple{IT, IT}, Tuple{IT, IT, IT}, Tuple{IT, IT, IT, FT}, Tuple{IT, IT, IT, FT, Any}} where {IT, FT}" href="#Sparspak.SpkProblem.Problem-Union{Tuple{FT}, Tuple{IT}, Tuple{IT, IT}, Tuple{IT, IT, IT}, Tuple{IT, IT, IT, FT}, Tuple{IT, IT, IT, FT, Any}} where {IT, FT}"><code>Sparspak.SpkProblem.Problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Problem(nrows::IT, ncols::IT, nnz::IT=2500, z::FT=0.0, info = &quot;&quot;) where {IT, FT}</code></pre><p>Construct a problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/Problem/SpkProblem.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.inaij!-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any, Any}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any, Any, Any}} where {IT, FT}" href="#Sparspak.SpkProblem.inaij!-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any, Any}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any, Any, Any}} where {IT, FT}"><code>Sparspak.SpkProblem.inaij!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inaij!(p::Problem{IT,FT}, rnum, cnum, aij=zero(FT)) where {IT,FT}</code></pre><p>Input a matrix coefficient. </p><p>The value is <em>added</em> to the existing contents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/Problem/SpkProblem.jl#L170-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.inbi!-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, IT, FT}} where {IT, FT}" href="#Sparspak.SpkProblem.inbi!-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, IT, FT}} where {IT, FT}"><code>Sparspak.SpkProblem.inbi!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inbi!(p::Problem{IT, FT}, rnum::IT, bi::FT) where {IT, FT}</code></pre><p>Input an entry of the right-hand side vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/Problem/SpkProblem.jl#L253-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.insparse!-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any}} where {IT, FT}" href="#Sparspak.SpkProblem.insparse!-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any}} where {IT, FT}"><code>Sparspak.SpkProblem.insparse!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insparse(p::Problem{IT,FT}, spm) where {IT,FT}</code></pre><p>Input sparse matrix.</p><p>Build a problem from a sparse matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/Problem/SpkProblem.jl#L273-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.infullrhs!" href="#Sparspak.SpkProblem.infullrhs!"><code>Sparspak.SpkProblem.infullrhs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">infullrhs!(p::Problem{IT,FT}, rhs)  where {IT,FT}</code></pre><p>InRHSProblem adds a vector of values, rhs, to the current right hand side of a problem object.</p><p>Input:</p><ul><li><code>rhs</code> - the source right-hand side. It <em>must</em> be of length at least       <code>p.nrows</code> and if it is greater than <code>p.nrows</code>, only the first       <code>p.nrows</code> are used.</li></ul><p>Updated:</p><ul><li><code>p</code> - the problem in which rhs is to be inserted.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/Problem/SpkProblem.jl#L498-L511">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.outsparse" href="#Sparspak.SpkProblem.outsparse"><code>Sparspak.SpkProblem.outsparse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outsparse(p::Problem{IT,FT})  where {IT,FT}</code></pre><p>Output the sparse matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/Problem/SpkProblem.jl#L300-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.computeresidual" href="#Sparspak.SpkProblem.computeresidual"><code>Sparspak.SpkProblem.computeresidual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">computeresidual(p::Problem, res::Vector{FT}, xin::Vector{FT} = FT[], mtype = &quot;T&quot;) where {FT}</code></pre><p>Compute the residual of a problem.</p><p>Given a vector <code>x</code>, this routine calculates the difference between the RHS of the given Problem and <code>A*x</code> and places this in <code>res</code>.</p><p>Input:</p><ul><li><code>p</code> - the <code>Problem</code> used to calculate <code>res</code>, using <code>xin</code></li><li><code>xin</code> - the input &quot;solution&quot; vector used to compute the residual</li><li><code>mtype</code> - matrix type (optional). If the matrix is symmetric and only           the lower or upper triangle is present, the user must let           the routine know this by setting mType to one of:               &quot;L&quot; or &quot;l&quot; - when only the lower triangle is present               &quot;U&quot; or &quot;u&quot; - when only the upper triangle is present               &quot;T&quot; or &quot;t&quot; - when either the lower or upper triangle is                            present.</li></ul><p>Output:</p><ul><li><code>res</code> - the calculated residual</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/Problem/SpkProblem.jl#L426-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.makerhs!" href="#Sparspak.SpkProblem.makerhs!"><code>Sparspak.SpkProblem.makerhs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makerhs(p::Problem, x::Vector{FT} = FT[], mtype = &quot;T&quot;) where {FT}</code></pre><p>This routine constructs the RHS of a problem given an <code>x</code> for the equation <code>Ax = rhs</code>. The <code>x</code> must have the same number of elements as the problem (represented by A above) has columns. If <code>x</code> is not present,  a right hand side is contructed so that the solution is 1, 2, 3, ...m.</p><p>Input Parameter:   x - the vector in the equation ``Ax = rhs&quot;&quot;   mType - matrix type (optional). If the matrix is symmetric and only             the lower or upper triangle is present, the user must let             the routine know this by setting mType to one of:                 &quot;L&quot; or &quot;l&quot; - when only the lower triangle is present                 &quot;U&quot; or &quot;u&quot; - when only the upper triangle is present                 &quot;T&quot; or &quot;t&quot; - when either the lower or upper triangle is                              present. Updated Parameter:    p - the problem for which the RHS is being constructed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/Problem/SpkProblem.jl#L381-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkProblem.makegridproblem" href="#Sparspak.SpkProblem.makegridproblem"><code>Sparspak.SpkProblem.makegridproblem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makegridproblem(g::Grid{IT}) where {IT}</code></pre><p>This routine fills in a problem object using a given grid.</p><p>Input:</p><ul><li><code>g</code> - the <code>Grid</code> to be used to fill a <code>Problem</code> matrix</li></ul><p>Output:</p><ul><li><code>p</code> - the Problem object to be filled</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/Problem/SpkProblem.jl#L329-L339">source</a></section><section><div><pre><code class="nohighlight hljs">makegridproblem(h::IT, k::IT) where {IT}</code></pre><p>Construct a problem object based on a grid.</p><p>Input:</p><ul><li><code>h</code> - the number of rows in the Grid</li><li><code>k</code> - the number of columns in the Grid</li></ul><p>Output:</p><ul><li><code>p</code> - the Problem object to be filled</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/Problem/SpkProblem.jl#L364-L375">source</a></section></article><h2 id="Sparse-LU-Solver"><a class="docs-heading-anchor" href="#Sparse-LU-Solver">Sparse LU Solver</a><a id="Sparse-LU-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Sparse-LU-Solver" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseSolver.SparseSolver" href="#Sparspak.SpkSparseSolver.SparseSolver"><code>Sparspak.SpkSparseSolver.SparseSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SparseSolver{IT, FT}</code></pre><p>Type of LU general sparse solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/SparseMethod/SpkSparseSolver.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseSolver.findorder!" href="#Sparspak.SpkSparseSolver.findorder!"><code>Sparspak.SpkSparseSolver.findorder!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findorder!(s::SparseSolver{IT}, orderfunction::F) where {IT, F}</code></pre><p>Find reordering of the coefficient matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/SparseMethod/SpkSparseSolver.jl#L47-L52">source</a></section><section><div><pre><code class="nohighlight hljs">findorder!(s::SparseSolver{IT}) where {IT, F}</code></pre><p>Find reordering of the coefficient matrix using the default method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/SparseMethod/SpkSparseSolver.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseSolver.findorderperm!" href="#Sparspak.SpkSparseSolver.findorderperm!"><code>Sparspak.SpkSparseSolver.findorderperm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">findorderperm!(s::SparseSolver{IT}, perm) where {IT}</code></pre><p>Find reordering of the coefficient matrix using a given permutation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/SparseMethod/SpkSparseSolver.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseSolver.symbolicfactor!" href="#Sparspak.SpkSparseSolver.symbolicfactor!"><code>Sparspak.SpkSparseSolver.symbolicfactor!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">symbolicfactor!(s::SparseSolver{IT})</code></pre><p>Symbolic factorization of the(reordered) matrix A.</p><p>Create the data structures for the factorization and forward and backward substitution. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/SparseMethod/SpkSparseSolver.jl#L90-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseSolver.inmatrix!" href="#Sparspak.SpkSparseSolver.inmatrix!"><code>Sparspak.SpkSparseSolver.inmatrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inmatrix!(s::SparseSolver{IT}, p::Problem{IT}) where {IT}</code></pre><p>Put numerical values of the matrix stored in the problem into the data structures of the solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/SparseMethod/SpkSparseSolver.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseSolver.factor!" href="#Sparspak.SpkSparseSolver.factor!"><code>Sparspak.SpkSparseSolver.factor!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">factor!(s::SparseSolver{IT}) where {IT}</code></pre><p>Numerical factorization of the coefficient matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/SparseMethod/SpkSparseSolver.jl#L127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseSolver.triangularsolve!" href="#Sparspak.SpkSparseSolver.triangularsolve!"><code>Sparspak.SpkSparseSolver.triangularsolve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">triangularsolve!(s::SparseSolver{IT},  p::Problem{IT}) where {IT}</code></pre><p>Forward and backward substitution (triangular solution).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/SparseMethod/SpkSparseSolver.jl#L146-L150">source</a></section><section><div><pre><code class="nohighlight hljs">triangularsolve!(s::SparseSolver{IT, FT}, solution::Vector{FT}) where {IT, FT}</code></pre><p>Forward and backward substitution (triangular solution).</p><p>Variant where the right-hand side vector is passed in.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/SparseMethod/SpkSparseSolver.jl#L168-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkSparseSolver.solve!" href="#Sparspak.SpkSparseSolver.solve!"><code>Sparspak.SpkSparseSolver.solve!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">solve!(s::SparseSolver{IT}, p::Problem{IT}) where {IT}</code></pre><p>Execute all the steps of the solution process.</p><p>Given a symmetric matrix <code>A</code>, the steps are:</p><ol><li>Reordering of the matrix <code>A</code>. </li><li>Symbolic factorization of the(reordered) matrix <code>A</code>. </li><li>Putting numerical values of <code>A</code> into the data structures. </li><li>Numerical factorization of <code>A</code>. </li><li>Forward and backward substitution (triangular solution).</li></ol><p>The solution can be retrieved as <code>p.x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/SparseMethod/SpkSparseSolver.jl#L185-L199">source</a></section></article><h2 id="Graphs"><a class="docs-heading-anchor" href="#Graphs">Graphs</a><a id="Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Graphs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkGraph.Graph-Union{Tuple{Sparspak.SpkProblem.Problem{IT}}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT}, Any}} where IT" href="#Sparspak.SpkGraph.Graph-Union{Tuple{Sparspak.SpkProblem.Problem{IT}}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT}, Any}} where IT"><code>Sparspak.SpkGraph.Graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Graph(p::Problem{IT}, diagonal=false) where {IT}</code></pre><p>Construct a graph from a problem object.</p><p>It does not check that the problem object contains a structurally symmetric matrix, since sometimes only the lower or upper triangle of a symmetric matrix may be stored. There are routines in this module to make a given graph object structurally symmetric.</p><p>Input:</p><ul><li><code>p</code> - the problem object, used to create the graph</li><li><code>diagonal</code> - indicates that the diagonal elements are included. If   diagonal is not given, the adjacency structure does not include   the diagonal elements.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/Graph/SpkGraph.jl#L67-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkGraph.makestructuresymmetric-Union{Tuple{Sparspak.SpkGraph.Graph{IT}}, Tuple{IT}} where IT" href="#Sparspak.SpkGraph.makestructuresymmetric-Union{Tuple{Sparspak.SpkGraph.Graph{IT}}, Tuple{IT}} where IT"><code>Sparspak.SpkGraph.makestructuresymmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">makestructuresymmetric(g::Graph{IT}) where {IT}</code></pre><p>Make the graph structure symmetric.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/Graph/SpkGraph.jl#L114-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkGraph.sortgraph!-Union{Tuple{Sparspak.SpkGraph.Graph{IT}}, Tuple{IT}} where IT" href="#Sparspak.SpkGraph.sortgraph!-Union{Tuple{Sparspak.SpkGraph.Graph{IT}}, Tuple{IT}} where IT"><code>Sparspak.SpkGraph.sortgraph!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sortgraph!(g::Graph{IT}) where {IT}</code></pre><p>Sort the adjacency lists of the graph.</p><p>Important assumption: This works only for graphs that are symmetric.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/Graph/SpkGraph.jl#L295-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sparspak.SpkGraph.isstructuresymmetric-Union{Tuple{Sparspak.SpkGraph.Graph{IT}}, Tuple{IT}} where IT" href="#Sparspak.SpkGraph.isstructuresymmetric-Union{Tuple{Sparspak.SpkGraph.Graph{IT}}, Tuple{IT}} where IT"><code>Sparspak.SpkGraph.isstructuresymmetric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isstructuresymmetric(g::Graph{IT}) where {IT}</code></pre><p>Determines if a graph is structurally symmetric.</p><p>Important assumption: It is assumed that the adjacency lists are in increasing order.</p><p>Output: either true or false</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/Sparspak.jl/blob/2c50cb2db41c8b3113d35d1afbcc9efd84241e21/src/Graph/SpkGraph.jl#L316-L325">source</a></section></article><h2 id="Multiple-minimum-degree-(MMD)-ordering."><a class="docs-heading-anchor" href="#Multiple-minimum-degree-(MMD)-ordering.">Multiple minimum degree (MMD) ordering.</a><a id="Multiple-minimum-degree-(MMD)-ordering.-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-minimum-degree-(MMD)-ordering." title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>mmd(g::Graph, order::Ordering)</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Elimination-Trees"><a class="docs-heading-anchor" href="#Elimination-Trees">Elimination Trees</a><a id="Elimination-Trees-1"></a><a class="docs-heading-anchor-permalink" href="#Elimination-Trees" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>getetree!(g::Graph, order::Ordering, t::ETree)</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>getpostorder!(t::ETree{IT}, order::Ordering, weight) where {IT}</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Symbolic-Factorization"><a class="docs-heading-anchor" href="#Symbolic-Factorization">Symbolic Factorization</a><a id="Symbolic-Factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-Factorization" title="Permalink"></a></h2><h2 id="Grid"><a class="docs-heading-anchor" href="#Grid">Grid</a><a id="Grid-1"></a><a class="docs-heading-anchor-permalink" href="#Grid" title="Permalink"></a></h2></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Wednesday 8 June 2022 15:14">Wednesday 8 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
