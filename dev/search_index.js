var documenterSearchIndex = {"docs":
[{"location":"man/reference.html#Types","page":"Reference","title":"Types","text":"","category":"section"},{"location":"man/reference.html#Problem","page":"Reference","title":"Problem","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"CurrentModule = Sparspak.SpkProblem","category":"page"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Problem","category":"page"},{"location":"man/reference.html#Sparspak.SpkProblem.Problem","page":"Reference","title":"Sparspak.SpkProblem.Problem","text":"Problem{IT, FT}\n\nType of a sparse-matrix coupled linear algebraic equations problem.\n\nFields \n\nnrows: \nnumber of rows in the matrix\nnumber of elements in a row permutation\nncols:\nnumber of columns in the matrix\nnumber of elements in a column permutation\n\nOther variables:\n\nNOTE: a user can input (i, j, v), indicating that position (i, j) in the matrix contains the value v. Or, a user can input (i, j), indicating that position (i, j) is nonzero, but not specifying a value there. Hence the distinction between \"nonzeros\" and \"nonzero values\" below.\n\nnnz - number of nonzero * values * in the matrix.\ndnz - number of nonzero * values * on the diagonal of the matrix.\nnedges - number of nonzeros in the matrix.\ndedges - number of nonzeros on the diagonal of the matrix.\n\nThe elements of the matrix are stored by columns using three \"parallel\" arrays: (link, rowsubs, values). The first element of column i stored is found in values[head[i]]. The row subscript of the element is rowsubs[head[i]]. The next element in the column is values[link[head[i]]] and so on. A zero value for link marks the end of the column.\n\nNOTE: the elements in each column are stored in increasing order of row subscript. Some algorithms used in the package depend on this fact.\n\nThe right hand side of the matrix equation is stored in rhs, and the solution (when provided or computed) is stored in the array x. The size of the arrays is extended as required, and their lengths for not generally correspond to the number of nonzeros in the matrix: or the number of columns in the matrix.\n\nThe user can improve efficiency by providing an estimate of the number of nonzeros in the matrix -  - this is done via the optional keyword parameter nnz.\n\nSimilarly, the user can improve efficiency by providing estimates for the number of rows and columns in the matrix via the optional keyword parameters nrows and ncols.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Sparse-LU-Solver","page":"Reference","title":"Sparse LU Solver","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"CurrentModule = Sparspak.SpkSparseSolver","category":"page"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"SparseSolver","category":"page"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.SparseSolver","page":"Reference","title":"Sparspak.SpkSparseSolver.SparseSolver","text":"SparseSolver{IT, FT}\n\nType of LU general sparse solver.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Elimination-Trees","page":"Reference","title":"Elimination Trees","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"CurrentModule = Sparspak.SpkETree","category":"page"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"ETree","category":"page"},{"location":"man/reference.html#Sparspak.SpkETree.ETree","page":"Reference","title":"Sparspak.SpkETree.ETree","text":"ETree(nv::IT) where {IT}\n\nConstruct elimination tree.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Graphs","page":"Reference","title":"Graphs","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"CurrentModule = Sparspak.SpkGraph","category":"page"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Graph","category":"page"},{"location":"man/reference.html#Sparspak.SpkGraph.Graph","page":"Reference","title":"Sparspak.SpkGraph.Graph","text":"Graph{IT}\n\nnv - the number of vertices in the graph.\n(xadj, adj) - array pair storing the adjacency lists of the vertices.\n\nThe adjacency lists of the graph are stored in consecutive locations in the array adj. The adjacency list for the i - th vertex in the graph is stored in positions adj[k], k = xadj[i], .... xadj[i + 1] - 1.\n\nWhen the graph is symmetric, if vertex i is in vertex j'\"'s adjacency vertex j is in vertex i's list. Using the representation above each edge in the graph is stored twice.\n\nThere are no self - loops (no \"diagonal elements\") by default. If diagonal elements are required, just input \"diagonal\" or \"diag\".\n\nFor convenience in accessing the lists, xadj is of length nv + 1, with xadj[nV + 1] = nEdges + 1. Thus, accessing vertex nV's list is the same as for any other of the vertices.\n\nGraphs are created from Problem objects, which have a certain number of rows (nrows) and columns (ncols). These numbers are captured and stored in Graph objects as nrows and ncols as well.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Ordering","page":"Reference","title":"Ordering","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"CurrentModule = Sparspak.SpkOrdering","category":"page"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Ordering","category":"page"},{"location":"man/reference.html#Sparspak.SpkOrdering.Ordering","page":"Reference","title":"Sparspak.SpkOrdering.Ordering","text":"Ordering{IT}\n\nType of ordering of the rows and columns.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Grid","page":"Reference","title":"Grid","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"CurrentModule = Sparspak.SpkGrid","category":"page"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Grid","category":"page"},{"location":"man/reference.html#Sparspak.SpkGrid.Grid","page":"Reference","title":"Sparspak.SpkGrid.Grid","text":"Grid(h::IT, k::IT) where {IT}\n\nConstruct a grid with a given number of spacings.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Functions","page":"Reference","title":"Functions","text":"","category":"section"},{"location":"man/reference.html#Problem-2","page":"Reference","title":"Problem","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"CurrentModule = Sparspak.SpkProblem","category":"page"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Problem(nrows::IT, ncols::IT, nnz::IT=2500, z::FT=0.0, info = \"\") where {IT, \n    FT}\ninaij!\ninbi!\ninsparse!\ninfullrhs!\noutsparse\ncomputeresidual\nmakerhs\nmakegridproblem","category":"page"},{"location":"man/reference.html#Sparspak.SpkProblem.Problem-Union{Tuple{FT}, Tuple{IT}, Tuple{IT, IT}, Tuple{IT, IT, IT}, Tuple{IT, IT, IT, FT}, Tuple{IT, IT, IT, FT, Any}} where {IT, FT}","page":"Reference","title":"Sparspak.SpkProblem.Problem","text":"Problem(nrows::IT, ncols::IT, nnz::IT=2500, z::FT=0.0, info = \"\") where {IT, FT}\n\nConstruct a problem.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkProblem.inaij!","page":"Reference","title":"Sparspak.SpkProblem.inaij!","text":"inaij!(p::Problem{IT,FT}, rnum, cnum, aij=zero(FT)) where {IT,FT}\n\nInput a matrix coefficient. \n\nThe value is added to the existing contents.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Sparspak.SpkProblem.inbi!","page":"Reference","title":"Sparspak.SpkProblem.inbi!","text":"inbi!(p::Problem{IT, FT}, rnum::IT, bi::FT) where {IT, FT}\n\nInput an entry of the right-hand side vector.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Sparspak.SpkProblem.insparse!","page":"Reference","title":"Sparspak.SpkProblem.insparse!","text":"insparse(p::Problem{IT,FT}, spm) where {IT,FT}\n\nInput sparse matrix.\n\nBuild a problem from a sparse matrix.\n\n\n\n\n\ninsparse(p::Problem{IT,FT}, I::Vector{IT}, J::Vector{IT}, V::Vector{FT}) where \n{IT,FT}\n\nBuild a problem from a sparse matrix in the COO format.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Sparspak.SpkProblem.infullrhs!","page":"Reference","title":"Sparspak.SpkProblem.infullrhs!","text":"infullrhs!(p::Problem{IT,FT}, rhs)  where {IT,FT}\n\nInRHSProblem adds a vector of values, rhs, to the current right hand side of a problem object.\n\nInput:\n\nrhs - the source right-hand side. It must be of length at least       p.nrows and if it is greater than p.nrows, only the first       p.nrows are used.\n\nUpdated:\n\np - the problem in which rhs is to be inserted.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Sparspak.SpkProblem.outsparse","page":"Reference","title":"Sparspak.SpkProblem.outsparse","text":"outsparse(p::Problem{IT,FT})  where {IT,FT}\n\nOutput the sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Sparspak.SpkProblem.computeresidual","page":"Reference","title":"Sparspak.SpkProblem.computeresidual","text":"computeresidual(p::Problem, res::Vector{FT}, xin::Vector{FT} = FT[], mtype = \"T\") where {FT}\n\nCompute the residual of a problem.\n\nGiven a vector x, this routine calculates the difference between the RHS of the given Problem and A*x and places this in res.\n\nInput:\n\np - the Problem used to calculate res, using xin\nxin - the input \"solution\" vector used to compute the residual\nmtype - matrix type (optional). If the matrix is symmetric and only           the lower or upper triangle is present, the user must let           the routine know this by setting mType to one of:               \"L\" or \"l\" - when only the lower triangle is present               \"U\" or \"u\" - when only the upper triangle is present               \"T\" or \"t\" - when either the lower or upper triangle is                            present.\n\nOutput:    res - the calculated residual\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Sparspak.SpkProblem.makegridproblem","page":"Reference","title":"Sparspak.SpkProblem.makegridproblem","text":"makegridproblem(g::Grid{IT}) where {IT}\n\nThis routine fills in a problem object using a given grid.\n\nInput:\n\ng - the Grid to be used to fill a Problem matrix\n\nOutput:\n\np - the Problem object to be filled\n\n\n\n\n\nmakegridproblem(h::IT, k::IT) where {IT}\n\nConstruct a problem object based on a grid.\n\nInput:\n\nh - the number of rows in the Grid\nk - the number of columns in the Grid\n\nOutput:\n\np - the Problem object to be filled\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Sparse-LU-Solver-2","page":"Reference","title":"Sparse LU Solver","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"CurrentModule = Sparspak.SpkSparseSolver","category":"page"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"SparseSolver\nfindorder!\nfindorderperm!\nsymbolicfactor!\ninmatrix!\nfactor!\ntriangularsolve!\nsolve!","category":"page"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.findorder!","page":"Reference","title":"Sparspak.SpkSparseSolver.findorder!","text":"findorder!(s::SparseSolver{IT}, orderfunction::F) where {IT, F}\n\nFind reordering of the coefficient matrix.\n\n\n\n\n\nfindorder!(s::SparseSolver{IT}) where {IT, F}\n\nFind reordering of the coefficient matrix using the default method.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.findorderperm!","page":"Reference","title":"Sparspak.SpkSparseSolver.findorderperm!","text":"findorderperm!(s::SparseSolver{IT}, perm) where {IT}\n\nFind reordering of the coefficient matrix using a given permutation.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.symbolicfactor!","page":"Reference","title":"Sparspak.SpkSparseSolver.symbolicfactor!","text":"symbolicfactor!(s::SparseSolver{IT})\n\nSymbolic factorization of the(reordered) matrix A.\n\nCreate the data structures for the factorization and forward and backward substitution. \n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.inmatrix!","page":"Reference","title":"Sparspak.SpkSparseSolver.inmatrix!","text":"inmatrix!(s::SparseSolver{IT}, p::Problem{IT}) where {IT}\n\nPut numerical values of the matrix stored in the problem into the data structures of the solver.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.factor!","page":"Reference","title":"Sparspak.SpkSparseSolver.factor!","text":"factor!(s::SparseSolver{IT}) where {IT}\n\nNumerical factorization of the coefficient matrix.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.triangularsolve!","page":"Reference","title":"Sparspak.SpkSparseSolver.triangularsolve!","text":"triangularsolve!(s::SparseSolver{IT},  p::Problem{IT}) where {IT}\n\nForward and backward substitution (triangular solution).\n\n\n\n\n\ntriangularsolve!(s::SparseSolver{IT, FT}, solution::Vector{FT}) where {IT, FT}\n\nForward and backward substitution (triangular solution).\n\nVariant where the right-hand side vector is passed in.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.solve!","page":"Reference","title":"Sparspak.SpkSparseSolver.solve!","text":"solve!(s::SparseSolver{IT}, p::Problem{IT}) where {IT}\n\nExecute all the steps of the solution process.\n\nGiven a symmetric matrix A, the steps are:\n\nReordering of the matrix A. \nSymbolic factorization of the(reordered) matrix A. \nPutting numerical values of A into the data structures. \nNumerical factorization of A. \nForward and backward substitution (triangular solution).\n\nThe solution can be retrieved as p.x.\n\n\n\n\n\n","category":"function"},{"location":"man/reference.html#Graphs-2","page":"Reference","title":"Graphs","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkGraph]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/reference.html#Ordering-2","page":"Reference","title":"Ordering","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkOrdering]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/reference.html#Multiple-minimum-degree-(MMD)-ordering.","page":"Reference","title":"Multiple minimum degree (MMD) ordering.","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkMmd]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/reference.html#Elimination-Trees-2","page":"Reference","title":"Elimination Trees","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkETree]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/reference.html#Symbolic-Factorization","page":"Reference","title":"Symbolic Factorization","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkSymfct]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/reference.html#Grid-2","page":"Reference","title":"Grid","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkGrid]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Table of contents","category":"page"},{"location":"guide/guide.html#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"index.html#Sparspak-Documentation","page":"Home","title":"Sparspak Documentation","text":"","category":"section"},{"location":"index.html#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Solves systems of coupled linear algebraic equations with a sparse coefficient matrix.\nReorderings of various kinds are supported, including the Multiple Minimum Degree (MMD).\nFactorizations of various kinds are supported.\nSolutions with multiple right hand sides, and solutions with preserved structure but changed matrix coefficients are supported. ","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The latest release of Sparspak can be installed from the Julia REPL prompt with","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ]add Sparspak","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The closing square bracket switches to the package manager interface and the add commands installs Sparspak and any missing dependencies.  To return to the Julia REPL hit the delete key.","category":"page"},{"location":"index.html#Simple-usage","page":"Home","title":"Simple usage","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This code makes up a random-coefficient (but diagonally dominant) sparse matrix and a simple right hand side vector. The sparse linear algebraic equation problem is then solved with the LU factorization. The solution is tested against the solution with the built-in solver.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using LinearAlgebra\nusing SparseArrays\nusing Sparspak.Problem: Problem, insparse!, outsparse, infullrhs!\nusing Sparspak.SparseSolver: SparseSolver, solve!\n\nfunction _test()\n    n = 1357\n    A = sprand(n, n, 1/n)\n    A = -A - A' + 20 * LinearAlgebra.I\n    \n    p = Problem(n, n)\n    insparse!(p, A);\n    infullrhs!(p, 1:n);\n    \n    s = SparseSolver(p)\n    solve!(s, p)\n    A = outsparse(p)\n    x = A \\ p.rhs\n    @show norm(p.x - x) / norm(x) < 1.0e-6\n\n    return true\nend\n\n_test()","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For more details see the file test/test_sparse_method.jl, module msprs016.","category":"page"},{"location":"index.html#User-guide","page":"Home","title":"User guide","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"guide/guide.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Reference-Manual","page":"Home","title":"Reference Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The description of the types and the functions, organized by module and/or other logical principle.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"man/reference.md\",\n]\nDepth = 3","category":"page"}]
}
