var documenterSearchIndex = {"docs":
[{"location":"man/reference.html#Types","page":"Reference","title":"Types","text":"","category":"section"},{"location":"man/reference.html#Problem","page":"Reference","title":"Problem","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkProblem]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/reference.html#Sparspak.SpkProblem.Problem","page":"Reference","title":"Sparspak.SpkProblem.Problem","text":"Problem{IT, FT}\n\nType of a sparse-matrix coupled linear algebraic equations problem.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Sparspak.SpkProblem.Problem-Union{Tuple{FT}, Tuple{IT}, Tuple{IT, IT}, Tuple{IT, IT, IT}, Tuple{IT, IT, IT, FT}, Tuple{IT, IT, IT, FT, Any}} where {IT, FT}","page":"Reference","title":"Sparspak.SpkProblem.Problem","text":"Problem(nrows::IT, ncols::IT, nnz::IT=2500, z::FT=0.0, info = \"\") where {IT, FT}\n\nConstruct a problem.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparse-LU-Method","page":"Reference","title":"Sparse LU Method","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkSparseSolver]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.SparseSolver","page":"Reference","title":"Sparspak.SpkSparseSolver.SparseSolver","text":"SparseSolver{IT, FT}\n\nType of LU general sparse solver.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Sparse-LU-SPD-Method","page":"Reference","title":"Sparse LU SPD Method","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Functions for Symmetric Positive Definite (SPD) matrices.","category":"page"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkSparseSolver]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/reference.html#Elimination-Trees","page":"Reference","title":"Elimination Trees","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkETree]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/reference.html#Sparspak.SpkETree.ETree-Tuple{IT} where IT","page":"Reference","title":"Sparspak.SpkETree.ETree","text":"ETree(nv::IT) where {IT}\n\nConstruct elimination tree.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Graphs","page":"Reference","title":"Graphs","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkGraph]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/reference.html#Sparspak.SpkGraph.Graph-Union{Tuple{Sparspak.SpkProblem.Problem{IT}}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT}, Any}} where IT","page":"Reference","title":"Sparspak.SpkGraph.Graph","text":"This routine constructs a graph from a problem object.\n\n\n\nIt does not check that the problem object contains a structurally   symmetric matrix, since sometimes only the lower or upper triangle of   a symmetric matrix may be stored. There are routines in this module to   make a given graph object structurally symmetric.\n\n\n\nInput:   g - the graph object, declared by the calling routine   p - the problem object, used to create the graph   diagonal - indicates that the diagonal elements are included. If     diagonal is not given, the adjacency structure does not include     the diagonal elements.   objectName - (optional) name to be assigned to g. Updated Parameter:    g - created graph object.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Ordering","page":"Reference","title":"Ordering","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkOrdering]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/reference.html#Sparspak.SpkOrdering.Ordering","page":"Reference","title":"Sparspak.SpkOrdering.Ordering","text":"Ordering{IT}\n\nType of ordering of the rows and columns.\n\n\n\n\n\n","category":"type"},{"location":"man/reference.html#Sparspak.SpkOrdering.Ordering-Tuple{IT} where IT","page":"Reference","title":"Sparspak.SpkOrdering.Ordering","text":"Ordering(nrows::IT) where {IT}\n\nConstruct an ordering object. \n\nSince only one parameter(nrows) is supplied, it is assumed that the size of the row ordering and column ordering are the same. That is, that the matrix is square.\n\nInput Parameters:   order - the ordering (declared in the calling program)   nRows - the number of rows (and columns) in the matrix   objectName - the name of the ordering object (optional)\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkOrdering.Ordering-Union{Tuple{IT}, Tuple{IT, IT}} where IT","page":"Reference","title":"Sparspak.SpkOrdering.Ordering","text":"Ordering(nrows::IT, ncols::IT) where {IT}\n\nConstruct an ordering object. \n\nThe arrays rperm, cperm, rinvp, cinvp are allocated and initialized to the identity permutation.\n\nInput Parameter:   order - the ordering (declared in the calling program)   nRows, nCols - the number of rows and columns in the matrix   objectName - the name of the ordering object (optional)\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Grid","page":"Reference","title":"Grid","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkGrid]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/reference.html#Sparspak.SpkGrid.Grid-Union{Tuple{IT}, Tuple{IT, IT}} where IT","page":"Reference","title":"Sparspak.SpkGrid.Grid","text":"Grid(h::IT, k::IT) where {IT}\n\nConstruct a grid with a given number of spacings.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Functions","page":"Reference","title":"Functions","text":"","category":"section"},{"location":"man/reference.html#Problem-2","page":"Reference","title":"Problem","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkProblem]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/reference.html#Sparspak.SpkProblem.computeresidual-Union{Tuple{FT}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}, Vector{FT}}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}, Vector{FT}, Any}} where FT","page":"Reference","title":"Sparspak.SpkProblem.computeresidual","text":"computeresidual(p::Problem, res::Vector{FT}, xin::Vector{FT} = FT[], mtype = \"T\") where {FT}\n\nCompute the residual of a problem.\n\nGiven a vector x, this routine calculates the difference between the RHS of the given Problem and A*x and places this in res.\n\nInput:\n\np - the Problem used to calculate res, using xin\nxin - the input \"solution\" vector used to compute the residual\nmtype - matrix type (optional). If the matrix is symmetric and only           the lower or upper triangle is present, the user must let           the routine know this by setting mType to one of:               \"L\" or \"l\" - when only the lower triangle is present               \"U\" or \"u\" - when only the upper triangle is present               \"T\" or \"t\" - when either the lower or upper triangle is                            present.\n\nOutput:    res - the calculated residual\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkProblem.inaij-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any, Any}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any, Any, Any}} where {IT, FT}","page":"Reference","title":"Sparspak.SpkProblem.inaij","text":"inaij(p::Problem{IT,FT}, rnum, cnum, aij=zero(FT)) where {IT,FT}\n\nInput a matrix coefficient. \n\nThe value is added to the existing contents.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkProblem.inbi-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, IT, FT}} where {IT, FT}","page":"Reference","title":"Sparspak.SpkProblem.inbi","text":"inbi(p::Problem{IT, FT}, rnum::IT, bi::FT) where {IT, FT}\n\nInput an entry of the right-hand side vector.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkProblem.infullrhs-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any}} where {IT, FT}","page":"Reference","title":"Sparspak.SpkProblem.infullrhs","text":"infullrhs(p::Problem{IT,FT}, rhs)  where {IT,FT}\n\nInRHSProblem adds a vector of values, rhs, to the current right hand side of a problem object.\n\nInput:\n\nrhs - the source right-hand side. It must be of length at least       p.nrows and if it is greater than p.nrows, only the first       p.nrows are used.\n\nUpdated:\n\np - the problem in which rhs is to be inserted.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkProblem.insparse-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any}} where {IT, FT}","page":"Reference","title":"Sparspak.SpkProblem.insparse","text":"insparse(p::Problem{IT,FT}, spm) where {IT,FT}\n\nInput sparse matrix.\n\nBuild a problem from a sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkProblem.insparse-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Vector{IT}, Vector{IT}, Vector{FT}}} where {IT, FT}","page":"Reference","title":"Sparspak.SpkProblem.insparse","text":"insparse(p::Problem{IT,FT}, I::Vector{IT}, J::Vector{IT}, V::Vector{FT}) where \n{IT,FT}\n\nBuild a problem from a sparse matrix in the COO format.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkProblem.makegridproblem-Union{Tuple{IT}, Tuple{IT, IT}} where IT","page":"Reference","title":"Sparspak.SpkProblem.makegridproblem","text":"makegridproblem(h::IT, k::IT) where {IT}\n\nConstruct a problem object based on a grid.\n\nInput:\n\nh - the number of rows in the Grid\nk - the number of columns in the Grid\n\nOutput:\n\np - the Problem object to be filled\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkProblem.makegridproblem-Union{Tuple{Sparspak.SpkGrid.Grid{IT}}, Tuple{IT}} where IT","page":"Reference","title":"Sparspak.SpkProblem.makegridproblem","text":"makegridproblem(g::Grid{IT}) where {IT}\n\nThis routine fills in a problem object using a given grid.\n\nInput:\n\ng - the Grid to be used to fill a Problem matrix\n\nOutput:\n\np - the Problem object to be filled\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkProblem.makerhs-Union{Tuple{FT}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}, Any}} where FT","page":"Reference","title":"Sparspak.SpkProblem.makerhs","text":"makerhs(p::Problem, x::Vector{FT} = FT[], mtype = \"T\") where {FT}\n\nThis routine constructs the RHS of a problem given an x for the equation Ax = rhs. The x must have the same number of elements as the problem (represented by A above) has columns. If x is not present,  a right hand side is contructed so that the solution is 1, 2, 3, ...m.\n\nInput Parameter:   x - the vector in the equation ``Ax = rhs\"\"   mType - matrix type (optional). If the matrix is symmetric and only             the lower or upper triangle is present, the user must let             the routine know this by setting mType to one of:                 \"L\" or \"l\" - when only the lower triangle is present                 \"U\" or \"u\" - when only the upper triangle is present                 \"T\" or \"t\" - when either the lower or upper triangle is                              present. Updated Parameter:    p - the problem for which the RHS is being constructed.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkProblem.outsparse-Union{Tuple{Sparspak.SpkProblem.Problem{IT, FT}}, Tuple{FT}, Tuple{IT}} where {IT, FT}","page":"Reference","title":"Sparspak.SpkProblem.outsparse","text":"outsparse(p::Problem{IT,FT})  where {IT,FT}\n\nOutput the sparse matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparse-LU-Method-2","page":"Reference","title":"Sparse LU Method","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkSparseSolver]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.factor-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{IT}} where IT","page":"Reference","title":"Sparspak.SpkSparseSolver.factor","text":"factor(s::SparseSolver{IT}) where {IT}\n\nNumerical factorization of the coefficient matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.findorder-Union{Tuple{F}, Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, F}} where {IT, F}","page":"Reference","title":"Sparspak.SpkSparseSolver.findorder","text":"findorder(s::SparseSolver{IT}, orderfunction::F) where {IT, F}\n\nFind reordering of the coefficient matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.findorder-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{F}, Tuple{IT}} where {IT, F}","page":"Reference","title":"Sparspak.SpkSparseSolver.findorder","text":"findorder(s::SparseSolver{IT}) where {IT, F}\n\nFind reordering of the coefficient matrix using the default method.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.findorderperm-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Any}} where IT","page":"Reference","title":"Sparspak.SpkSparseSolver.findorderperm","text":"findorderperm(s::SparseSolver{IT}, perm) where {IT}\n\nFind reordering of the coefficient matrix using a given permutation.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.inmatrix-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT","page":"Reference","title":"Sparspak.SpkSparseSolver.inmatrix","text":"inmatrix(s::SparseSolver{IT}, p::Problem{IT}) where {IT}\n\nPut numerical values of the matrix stored in the problem into the data structures of the solver.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.solve-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT","page":"Reference","title":"Sparspak.SpkSparseSolver.solve","text":"solve(s::SparseSolver{IT}, p::Problem{IT}) where {IT}\n\nExecute all the steps of the solution process.\n\nGiven a symmetric matrix A, the steps are:\n\nReordering of the matrix A. \nSymbolic factorization of the(reordered) matrix A. \nPutting numerical values of A into the data structures. \nNumerical factorization of A. \nForward and backward substitution (triangular solution).\n\nThe solution can be retrieved as p.x.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.symbolicfactor-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{IT}} where IT","page":"Reference","title":"Sparspak.SpkSparseSolver.symbolicfactor","text":"symbolicfactor(s::SparseSolver{IT})\n\nSymbolic factorization of the(reordered) matrix A.\n\nCreate the data structures for the factorization and forward and backward substitution. \n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.triangularsolve-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT, FT}, Vector{FT}}} where {IT, FT}","page":"Reference","title":"Sparspak.SpkSparseSolver.triangularsolve","text":"triangularsolve(s::SparseSolver{IT, FT}, solution::Vector{FT}) where {IT, FT}\n\nForward and backward substitution (triangular solution).\n\nVariant where the right-hand side vector is passed in.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkSparseSolver.triangularsolve-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT","page":"Reference","title":"Sparspak.SpkSparseSolver.triangularsolve","text":"triangularsolve(s::SparseSolver{IT},  p::Problem{IT}) where {IT}\n\nForward and backward substitution (triangular solution).\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Graphs-2","page":"Reference","title":"Graphs","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkGraph]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/reference.html#Sparspak.SpkGraph.sortgraph-Union{Tuple{Sparspak.SpkGraph.Graph{IT}}, Tuple{IT}} where IT","page":"Reference","title":"Sparspak.SpkGraph.sortgraph","text":"SortGraph - sort the adjacency lists of the graph Important assumption:   This works only for graphs that are symmetric.  Output: updated graph\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Ordering-2","page":"Reference","title":"Ordering","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkOrdering]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/reference.html#Multiple-minimum-degree-(MMD)-ordering.","page":"Reference","title":"Multiple minimum degree (MMD) ordering.","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkMmd]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/reference.html#Sparspak.SpkMmd.generalmmd-Union{Tuple{IT}, Tuple{IT, Vector{IT}, Vector{IT}, Vector{IT}, Vector{IT}}} where IT","page":"Reference","title":"Sparspak.SpkMmd.generalmmd","text":"generalmmd(n, xadj, adj, perm, invp)\n\nThis routine implements the minimum degree algorithm.  It makes use of the implicit representation of elimination graphs by quotient graphs, and the notion of indistinguishable nodes.  It also implements the modifications by multiple elimination and minimum external degree.\n\nInput parameters -\n\nn - number of equations (xadj, adj) - adjacency structure for the graph. delta - tolerance value for multiple elimination. FIX ME: should delta be passed as argument?\n\nOutput:   perm, invp - the minimum degree Ordering.\n\nWorking arrays -   degHead (deg) - points to first node with degree deg, or 0 if there                are no such nodes.   degNext (node) - points to the next node in the degree list                associated with node, or 0 if node was the last in the                degree list.   degPrev (node) - points to the previous node in a degree list                associated with node, or the negative of the degree of                node (if node was the last in the degree list), or 0                if the node is not in the degree lists.   superSIze - the size of the supernodes.   elimHead - points to the first node eliminated in the current pass                Using elimNext, one can determine all nodes just                eliminated.   elimNext (node) - points to the next node in a eliminated supernode                or 0 if there are no more after node.   marker - marker vector.   mergeParent - the parent map for the merged forest.     needsUpdate (node) - > 0 iff node needs degree update.(0 otherwise)\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkMmd.mmdelim-NTuple{13, Any}","page":"Reference","title":"Sparspak.SpkMmd.mmdelim","text":"Purpose - This routine eliminates the node mdNode of\n  minimum degree from the adjacency structure, which\n  is stored in the quotient Graph format.  It also\n  transforms the quotient Graph representation of the\n  elimination Graph.\n\nInput parameters -       mdNode - node of minimum degree.       tag - tag value.       invp - the inverse of an incomplete minimum degree Ordering.                 (It is zero at positions where the Ordering is unknown.)    Updated parameters -       (xadj, adjncy) - updated adjacency structure (xadj is not updated).       degHead (deg) - points to first node with degree deg, or 0 if there                    are no such nodes.       degNext (node) - points to the next node in the degree list                    associated with node, or 0 if node was the last in the                    degree list.       degPrev (node) - points to the previous node in a degree list                    associated with node, or the negative of the degree of                    node (if node was the last in the degree list), or 0                    if the node is not in the degree lists.       superSIze - the size of the supernodes.       elimNext (node) - points to the next node in a eliminated supernode                    or 0 if there are no more after node.       marker - marker vector.       mergeParent - the parent map for the merged forest.        needsUpdate (node) - > 0 iff node needs update. (0 otherwise)\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkMmd.mmdupdate-NTuple{16, Any}","page":"Reference","title":"Sparspak.SpkMmd.mmdupdate","text":"Purpose - This routine updates the degrees of nodes\n  after a multiple elimination step.\n\nInput parameters -       elimHead - the beginning of the list of eliminated                nodes (i.e., newly formed elements).       neqns - number of equations.       (xadj, adjncy) - adjacency structure.       delta - tolerance value for multiple elimination.       invp - the inverse of an incomplete minimum degree Ordering.                (It is zero at positions where the Ordering is unknown.)    Updated parameters -       mindeg - new minimum degree after degree update.       degHead (deg) - points to first node with degree deg, or 0 if there                    are no such nodes.       degNext (node) - points to the next node in the degree list                    associated with node, or 0 if node was the last in the                    degree list.       degPrev (node) - points to the previous node in a degree list                    associated with node, or the negative of the degree of                    node (if node was the last in the degree list), or 0                    if the node is not in the degree lists.       superSIze - the size of the supernodes.       elimNext (node) - points to the next node in a eliminated supernode                    or 0 if there are no more after node.       marker - marker vector for degree update.       tag - tag value.       mergeParent - the parent map for the merged forest.        needsUpdate (node) - > 0 iff node needs update. (0 otherwise)\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Elimination-Trees-2","page":"Reference","title":"Elimination Trees","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkETree]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/reference.html#Sparspak.SpkETree.binarytree-NTuple{4, Any}","page":"Reference","title":"Sparspak.SpkETree.binarytree","text":"To determine the binary tree representation of the elimination   tree given by the parent vector.  The returned representation   will be given by the first - son and brother vectors.  The root   of the binary tree is always n.\n\nInput Parameters:   n - number of equations.   parent - the parent vector of the elimination tree.             It is assumed that parent(i) > i except for the roots.\n\nOutput Parameters:   fson - the first son vector.    brother - the brother vector.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkETree.findetree-NTuple{6, Any}","page":"Reference","title":"Sparspak.SpkETree.findetree","text":"To determine the elimination tree from a given ordering and the   adjacency structure. The parent vector is returned.\n\nInput Parameters:   n - number of equations.   (xadj, adj) - the adjacency structure.   (rPerm, rInvp) - permutation and inverse permutation vectors\n\nOutput Parameters:   parent - the parent vector of the elimination tree.\n\nWorking Storage:    ancestor - the ancestor vector.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkETree.getetree-Tuple{Sparspak.SpkGraph.Graph, Sparspak.SpkOrdering.Ordering, Sparspak.SpkETree.ETree}","page":"Reference","title":"Sparspak.SpkETree.getetree","text":"Given a graph and an ordering, GetETree finds the corresponding   elimination tree. It calls the subroutine FindETree, which actually   does the work.\n\nInput Parameter:   g - the graph whose elimination tree is to be found.   order - the ordering for g\n\nUpdated Parameters:    t - the elimination tree.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkETree.getpostorder-Union{Tuple{IT}, Tuple{Sparspak.SpkETree.ETree{IT}, Sparspak.SpkOrdering.Ordering, Any}} where IT","page":"Reference","title":"Sparspak.SpkETree.getpostorder","text":"GetPostorder finds a postordering of elimination tree t. The resulting   ordering is returned in the object order The vector argumentweight\"\" is optional. If it is present,  the postordering will   be one where the child vertices are ordered in increasing order of   their weights.   The elimination tree is reordered according to the postordering.\n\nInput Parameters:   t - the e - tree for which the postordering is found.   weight - an optional weighting on the tree\n\nUpdated Parameters:   order - the required ordering\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkETree.postordertree-NTuple{6, Any}","page":"Reference","title":"Sparspak.SpkETree.postordertree","text":"Based on the binary representation (first - son, brother) of the   elimination tree, a postordering is determined. The corresponding   parent vector is also modified to reflect the reordering.\n\nInput Parameters:   root - root of the elimination tree (usually n).   fson - the first son vector.   brother - the brother vector.\n\nUpdated Parameters:   parent - the parent vector.\n\nOutput Parameters:   rInvpos - inverse permutation for the postordering.\n\nWorking Parameters:    stack - the stack for postorder traversal of the tree.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Sparspak.SpkETree.weightedbinarytree-NTuple{5, Any}","page":"Reference","title":"Sparspak.SpkETree.weightedbinarytree","text":"To determine a binary tree representation of the elimination   tree, for which every \"last child\" has the maximum possible   column nonzero count in the factor.  The returned representation   will be given by the first - son and brother vectors.  The root of   the binary tree is always n.\n\nInput Parameters:   n - number of equations.   parent - the parent vector of the elimination tree.             It is assumed that parent(i) > i except for the roots.   weight - a weighting on the tree.\n\nOutput Parameters:   fson - the first son vector.   brother - the brother vector.\n\nWorking Storage:    lson - last son vector.\n\n\n\n\n\n","category":"method"},{"location":"man/reference.html#Symbolic-Factorization","page":"Reference","title":"Symbolic Factorization","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkSymfct]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/reference.html#Grid-2","page":"Reference","title":"Grid","text":"","category":"section"},{"location":"man/reference.html","page":"Reference","title":"Reference","text":"Modules = [Sparspak.SpkGrid]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Table of contents","category":"page"},{"location":"guide/guide.html#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"index.html#Sparspak-Documentation","page":"Home","title":"Sparspak Documentation","text":"","category":"section"},{"location":"index.html#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Solves systems of coupled linear algebraic equations with a sparse coefficient matrix.\nReorderings of various kinds are supported, including the Multiple Minimum Degree (MMD).\nFactorizations of various kinds are supported.\nSolutions with multiple right hand sides, and solutions with preserved structure but changed matrix coefficients are supported. ","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The latest release of Sparspak can be installed from the Julia REPL prompt with","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ]add Sparspak","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The closing square bracket switches to the package manager interface and the add commands installs Sparspak and any missing dependencies.  To return to the Julia REPL hit the delete key.","category":"page"},{"location":"index.html#Simple-example","page":"Home","title":"Simple example","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This code makes up a random-coefficient (but diagonally dominant) sparse matrix and a simple right hand side vector. The sparse linear algebraic equation problem is then solved with the LU factorization. The solution is tested against the solution with the built-in solver.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Sparspak.Problem: Problem, insparse, outsparse, infullrhs\nusing Sparspak.SparseSolver: SparseSolver, solve\n\nfunction _test()\n    n = 1357\n    A = sprand(n, n, 1/n)\n    A = -A - A' + 20 * LinearAlgebra.I\n    \n    p = Problem(n, n)\n    insparse(p, A);\n    infullrhs(p, 1:n);\n    \n    s = SparseSolver(p)\n    solve(s, p)\n    A = outsparse(p)\n    x = A \\ p.rhs\n    @test norm(p.x - x) / norm(x) < 1.0e-6\n\n    return true\nend\n\n_test()","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For more details see the file test/test_sparse_method.jl, module msprs016.","category":"page"},{"location":"index.html#User-guide","page":"Home","title":"User guide","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"guide/guide.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The description of the types and the functions, organized by module and/or other logical principle.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"man/reference.md\",\n]\nDepth = 3","category":"page"}]
}
