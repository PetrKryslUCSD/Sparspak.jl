var documenterSearchIndex = {"docs":
[{"location":"guide/guide.html","page":"Guide","title":"Guide","text":"Table of contents","category":"page"},{"location":"guide/guide.html#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"index.html#FinEtools-(Finite-Element-tools)-Documentation","page":"Home","title":"FinEtools (Finite Element tools) Documentation","text":"","category":"section"},{"location":"index.html#Conceptual-guide","page":"Home","title":"Conceptual guide","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The construction of the toolkit is described: the composition of modules, the basic data structures, the methodology of computing quantities required in the finite element methodology, and more.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"guide/guide.md\",\n]\nDepth = 1","category":"page"},{"location":"index.html#Manual","page":"Home","title":"Manual","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The description of the types and the functions, organized by module and/or other logical principle.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Pages = [\n    \"man/types.md\",\n    \"man/functions.md\",\n]\nDepth = 3","category":"page"},{"location":"man/types.html#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"man/types.html#Problem","page":"Types","title":"Problem","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [Sparspak.SpkProblem]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#Sparspak.SpkProblem.Problem-Union{Tuple{FT}, Tuple{IT}, Tuple{IT, IT}, Tuple{IT, IT, IT}, Tuple{IT, IT, IT, FT}, Tuple{IT, IT, IT, FT, Any}} where {IT, FT}","page":"Types","title":"Sparspak.SpkProblem.Problem","text":"\n\n\n\n","category":"method"},{"location":"man/types.html#Sparse-LU-Method","page":"Types","title":"Sparse LU Method","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [Sparspak.SpkSparseSolver]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#Sparse-LU-SPD-Method","page":"Types","title":"Sparse LU SPD Method","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Functions for Symmetric Positive Definite (SPD) matrices.","category":"page"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [Sparspak.SpkSparseSolver]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#Elimination-Trees","page":"Types","title":"Elimination Trees","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [Sparspak.SpkETree]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#Sparspak.SpkETree.ETree-Tuple{IT} where IT","page":"Types","title":"Sparspak.SpkETree.ETree","text":"\n\n\n\n","category":"method"},{"location":"man/types.html#Graphs","page":"Types","title":"Graphs","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [Sparspak.SpkGraph]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#Sparspak.SpkGraph.Graph-Union{Tuple{Sparspak.SpkProblem.Problem{IT}}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT}, Any}} where IT","page":"Types","title":"Sparspak.SpkGraph.Graph","text":"This routine constructs a graph from a problem object.\n\n\n\nIt does not check that the problem object contains a structurally   symmetric matrix, since sometimes only the lower or upper triangle of   a symmetric matrix may be stored. There are routines in this module to   make a given graph object structurally symmetric.\n\n\n\nInput:   g - the graph object, declared by the calling routine   p - the problem object, used to create the graph   diagonal - indicates that the diagonal elements are included. If     diagonal is not given, the adjacency structure does not include     the diagonal elements.   objectName - (optional) name to be assigned to g. Updated Parameter:    g - created graph object.\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Ordering","page":"Types","title":"Ordering","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [Sparspak.SpkOrdering]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#Sparspak.SpkOrdering.Ordering-Tuple{IT} where IT","page":"Types","title":"Sparspak.SpkOrdering.Ordering","text":"ConstructOrdering constructs an ordering object. Since only one   parameter (nRows) is supplied, it is assumed that the size of the   row ordering and column ordering are the same. That is, that the   matrix is square. Input Parameters:   order - the ordering (declared in the calling program)   nRows - the number of rows (and columns) in the matrix   objectName - the name of the ordering object (optional) Output Parameter:    order - the updated ordering object\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Sparspak.SpkOrdering.Ordering-Union{Tuple{IT}, Tuple{IT, IT}} where IT","page":"Types","title":"Sparspak.SpkOrdering.Ordering","text":"ConstructOrdering2 constructs an ordering object. The arrays   rPerm, cPerm, rInvp, cInvp are allocated and initialized to   the identity permutation. Input Parameter:   order - the ordering (declared in the calling program)   nRows, nCols - the number of rows and columns in the matrix   objectName - the name of the ordering object (optional) Output Parameter:    order - the updated ordering object\n\n\n\n\n\n","category":"method"},{"location":"man/types.html#Grid","page":"Types","title":"Grid","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [Sparspak.SpkGrid]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/types.html#Sparspak.SpkGrid.Grid-Union{Tuple{IT}, Tuple{IT, IT}} where IT","page":"Types","title":"Sparspak.SpkGrid.Grid","text":"\n\n\n\n","category":"method"},{"location":"man/types.html#Utilities","page":"Types","title":"Utilities","text":"","category":"section"},{"location":"man/types.html","page":"Types","title":"Types","text":"Modules = [Sparspak.SpkUtilities]\nPrivate = true\nOrder = [:type]","category":"page"},{"location":"man/functions.html#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"man/functions.html#Problem","page":"Functions","title":"Problem","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [Sparspak.SpkProblem]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Sparspak.SpkProblem.infullrhs-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkProblem.Problem{IT, FT}, Any}} where {IT, FT}","page":"Functions","title":"Sparspak.SpkProblem.infullrhs","text":"\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparspak.SpkProblem.makegridproblem-Union{Tuple{IT}, Tuple{IT, IT}} where IT","page":"Functions","title":"Sparspak.SpkProblem.makegridproblem","text":"This routine constructs a Grid object given an H and K, and fills in a   Problem object using this Grid. Input Parameters:   h - the number of rows in the Grid   k - the number of columns in the Grid   stencil - an optional variable specifying the difference operator             to be applied to the grid. Output Parameter:    p - the Problem object to be filled\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparspak.SpkProblem.makegridproblem-Union{Tuple{Sparspak.SpkGrid.Grid{IT}}, Tuple{IT}} where IT","page":"Functions","title":"Sparspak.SpkProblem.makegridproblem","text":"This routine fills in a Problem object using a given Grid. Input Parameters:   g - the Grid to be used to fill a Problem matrix   stencil - an optional variable specifying the difference operator             to be applied to the grid. Output Parameter:    p - the Problem object to be filled\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparspak.SpkProblem.makerhs-Union{Tuple{Sparspak.SpkProblem.Problem}, Tuple{FT}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}}, Tuple{Sparspak.SpkProblem.Problem, Vector{FT}, Any}} where FT","page":"Functions","title":"Sparspak.SpkProblem.makerhs","text":"This routine constructs the RHS of a problem given an x for the   equation Ax = rhs The x must have the same number of elements   as the problem (represented by A above) has columns   If x is not present  a right hand side is contructed so that   (a the) solution is 1 2 3 m Input Parameter   x - the vector in the equationAx = rhs\"\"   mType - matrix type (optional). If the matrix is symmetric and only             the lower or upper triangle is present, the user must let             the routine know this by setting mType to one of:                 \"L\" or \"l\" - when only the lower triangle is present                 \"U\" or \"u\" - when only the upper triangle is present                 \"T\" or \"t\" - when either the lower or upper triangle is                              present. Updated Parameter:    p - the problem for which the RHS is being constructed.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparse-LU-Method","page":"Functions","title":"Sparse LU Method","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [Sparspak.SpkSparseSolver]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Sparspak.SpkSparseBase.factor-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{IT}} where IT","page":"Functions","title":"Sparspak.SpkSparseBase.factor","text":"factor(s::SparseSolver{IT}) where {IT}\n\nNumerical factorization of the coefficient matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparspak.SpkSparseBase.findorder-Union{Tuple{F}, Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, F}} where {IT, F}","page":"Functions","title":"Sparspak.SpkSparseBase.findorder","text":"findorder(s::SparseSolver{IT}, orderfunction::F) where {IT, F}\n\nFind reordering of the coefficient matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparspak.SpkSparseBase.findorder-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{F}, Tuple{IT}} where {IT, F}","page":"Functions","title":"Sparspak.SpkSparseBase.findorder","text":"findorder(s::SparseSolver{IT}) where {IT, F}\n\nFind reordering of the coefficient matrix using the default method.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparspak.SpkSparseBase.inmatrix-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT","page":"Functions","title":"Sparspak.SpkSparseBase.inmatrix","text":"inmatrix(s::SparseSolver{IT}, p::Problem{IT}) where {IT}\n\nPut numerical values of the matrix stored in the problem into the data structures of the solver.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparspak.SpkSparseBase.symbolicfactor-Union{Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}}, Tuple{IT}} where IT","page":"Functions","title":"Sparspak.SpkSparseBase.symbolicfactor","text":"symbolicfactor(s::SparseSolver{IT})\n\nSymbolic factorization of the(reordered) matrix A and the creation of the data structures for the factorization and forward and backward substitution. \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparspak.SpkSparseBase.triangularsolve-Union{Tuple{FT}, Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT, FT}, Vector{FT}}} where {IT, FT}","page":"Functions","title":"Sparspak.SpkSparseBase.triangularsolve","text":"triangularsolve(s::SparseSolver{IT, FT}, solution::Vector{FT}) where {IT, FT}\n\nForward and backward substitution (triangular solution).\n\nVariant where the right-hand side vector is passed in.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparspak.SpkSparseBase.triangularsolve-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT","page":"Functions","title":"Sparspak.SpkSparseBase.triangularsolve","text":"triangularsolve(s::SparseSolver{IT},  p::Problem{IT}) where {IT}\n\nForward and backward substitution (triangular solution).\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparspak.SpkSparseSolver.findorderperm-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Any}} where IT","page":"Functions","title":"Sparspak.SpkSparseSolver.findorderperm","text":"findorderperm(s::SparseSolver{IT}, perm) where {IT}\n\nFind reordering of the coefficient matrix using a given permutation.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparspak.SpkSparseSolver.solve-Union{Tuple{IT}, Tuple{Sparspak.SpkSparseSolver.SparseSolver{IT}, Sparspak.SpkProblem.Problem{IT}}} where IT","page":"Functions","title":"Sparspak.SpkSparseSolver.solve","text":"solve(s::SparseSolver{IT}, p::Problem{IT}) where {IT}\n\nExecute all the steps of the solution process:\n\nReordering of the matrix A \nSymbolic factorization of the(reordered) matrix A and the creation of the\n\ndata structures for the factorization and forward and backward substitution \n\nPutting numerical values of\n\nA into the data structures \n\nNumerical factorization of A \nForward and backward substitution (triangular solution) \n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparse-LU-SPD-Method","page":"Functions","title":"Sparse LU SPD Method","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Functions for Symmetric Positive Definite (SPD) matrices.","category":"page"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [Sparspak.SpkSparseSolver]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Elimination-Trees","page":"Functions","title":"Elimination Trees","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [Sparspak.SpkETree]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Sparspak.SpkETree.binarytree-NTuple{4, Any}","page":"Functions","title":"Sparspak.SpkETree.binarytree","text":"\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparspak.SpkETree.findetree-NTuple{6, Any}","page":"Functions","title":"Sparspak.SpkETree.findetree","text":"\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparspak.SpkETree.getetree-Tuple{Sparspak.SpkGraph.Graph, Sparspak.SpkOrdering.Ordering, Sparspak.SpkETree.ETree}","page":"Functions","title":"Sparspak.SpkETree.getetree","text":"Given a graph and an ordering, GetETree finds the corresponding   elimination tree. It calls the subroutine FindETree, which actually   does the work.\n\nInput Parameter:   g - the graph whose elimination tree is to be found.   order - the ordering for g\n\nUpdated Parameters:    t - the elimination tree.\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparspak.SpkETree.getpostorder-Union{Tuple{IT}, Tuple{Sparspak.SpkETree.ETree{IT}, Sparspak.SpkOrdering.Ordering, Any}} where IT","page":"Functions","title":"Sparspak.SpkETree.getpostorder","text":"\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparspak.SpkETree.postordertree-NTuple{6, Any}","page":"Functions","title":"Sparspak.SpkETree.postordertree","text":"\n\n\n\n","category":"method"},{"location":"man/functions.html#Sparspak.SpkETree.weightedbinarytree-NTuple{5, Any}","page":"Functions","title":"Sparspak.SpkETree.weightedbinarytree","text":"\n\n\n\n","category":"method"},{"location":"man/functions.html#Graphs","page":"Functions","title":"Graphs","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [Sparspak.SpkGraph]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Sparspak.SpkGraph.sortgraph-Union{Tuple{Sparspak.SpkGraph.Graph{IT}}, Tuple{IT}} where IT","page":"Functions","title":"Sparspak.SpkGraph.sortgraph","text":"SortGraph - sort the adjacency lists of the graph Important assumption:   This works only for graphs that are symmetric.  Output: updated graph\n\n\n\n\n\n","category":"method"},{"location":"man/functions.html#Ordering","page":"Functions","title":"Ordering","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [Sparspak.SpkOrdering]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Grid","page":"Functions","title":"Grid","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [Sparspak.SpkGrid]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Utilities","page":"Functions","title":"Utilities","text":"","category":"section"},{"location":"man/functions.html","page":"Functions","title":"Functions","text":"Modules = [Sparspak.SpkUtilities]\nPrivate = true\nOrder = [:function]","category":"page"},{"location":"man/functions.html#Sparspak.SpkUtilities.extend","page":"Functions","title":"Sparspak.SpkUtilities.extend","text":"extend(v::Vector, newlen::Integer, flagval=zero(eltype(v)))\n\nChange the size (smaller or larger).    \n\nThe contents of the vectors / arrays are preserved.\nThe changes in size may be positive or negative.\nflagval is the initialization value of the new parts of the arrays.   If it is absent,  the default is zero (for numerical arrays).\n\n\n\n\n\n","category":"function"},{"location":"man/functions.html#Sparspak.SpkUtilities.extend-2","page":"Functions","title":"Sparspak.SpkUtilities.extend","text":"extend(v::Matrix, newrow::Integer, newcol::Integer, flagval=zero(eltype(v)))\n\nChange the size of a matrix (smaller or larger).\n\n\n\n\n\n","category":"function"}]
}
